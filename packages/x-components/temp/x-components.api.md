## API Report File for "@empathyco/x-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionContext } from 'vuex';
import { ComponentOptions } from 'vue';
import { CreateElement } from 'vue';
import { DirectiveOptions } from 'vue';
import { ExtendedVue } from 'vue/types/vue';
import { Module } from 'vuex';
import { Observable } from 'rxjs';
import { PluginObject } from 'vue';
import { StorageService } from '@empathyco/x-storage-service';
import { Store } from 'vuex';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';
import { VNode } from 'vue';
import { default as Vue_2 } from 'vue';
import { Vue as Vue_3 } from 'vue-property-decorator';
import { VueClass } from 'vue-class-component/lib/declarations';
import { VueConstructor } from 'vue';
import { WatchOptions } from 'vue';

// @internal
export interface AbsoluteDistances {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export type ActionNamesFor<ModuleName extends XModuleName> = keyof ExtractActions<XModulesTree[ModuleName]>;

// @public
export type ActionsClass<Module extends AnyXStoreModule> = Partial<Module['actions']>;

// @public
export type ActionsDictionary<Actions> = Record<keyof Actions, (payload?: any) => any>;

// @public
export type ActionsTree<State extends Dictionary, Getters extends Dictionary, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> = {
    [Key in keyof Actions]: (context: XActionContext<State, Getters, Mutations, Actions>, payload: ExtractPayload<Actions[Key]>) => ReturnType<Actions[Key]> | Promise<ReturnType<Actions[Key]>>;
};

// @public
export const addQueryToHistory: ({ state, dispatch }: HistoryQueriesActionContext, query: string) => void | Promise<void>;

// @public
export class AddQueryToHistoryAction implements ActionsClass<HistoryQueriesXStoreModule> {
    addQueryToHistory({ state, dispatch }: HistoryQueriesActionContext, query: string): void | Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "HistoryQuery" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected createHistoryQuery(query: string): HistoryQuery_2;
    // @internal
    protected createNewHistory(currentHistory: HistoryQuery_2[], normalizedQuery: string): HistoryQuery_2[] | null;
    // @internal
    protected isAddAction([lastWords, newWords]: Pair<string[]>, [lastQuery, newQuery]: Pair<string>): boolean;
    // @internal
    protected isQueryBeingRefined(lastWords: string[], newWords: string[]): boolean;
    // @internal
    protected isReplaceAction([lastWords, newWords]: Pair<string[]>, [lastQuery, newQuery]: Pair<string>): boolean;
    // @internal
    protected removeNewQueryFromHistory(currentHistory: HistoryQuery_2[], normalizedQuery: string): HistoryQuery_2[];
}

// @public
export const addQueryToHistoryQueries: Wire<string>;

// @public
export class AnimateWidth extends Vue_2 {
}

// @public
export type AnyActionsTree = ActionsTree<Dictionary, Dictionary, MutationsDictionary<any>, ActionsDictionary<any>>;

// @public
export type AnyFunction = (...args: any[]) => any;

// @public
export type AnyGettersTree = GettersTree<Dictionary, Dictionary>;

// @public
export type AnyMutationsTree = MutationsTree<Dictionary, MutationsDictionary<any>>;

// @public
export type AnySimpleStateSelector = SimpleStateSelector<any, any, any>;

// @public
export type AnyStateSelector = StateSelector<any, any, any>;

// @public
export type AnyStoreEmitters = StoreEmitters<AnyXStoreModule>;

// @public
export type AnyWire = Wire<any>;

// @public
export type AnyXModule = XModule<AnyXStoreModule>;

// @public
export type AnyXStoreModule = XStoreModule<any, any, any, any>;

// @public
export type AnyXStoreModuleOption = XStoreModuleOptions<AnyXStoreModule>;

// Warning: (ae-forgotten-export) The symbol "Filter" needs to be exported by the entry point index.d.ts
//
// @public
export function areFiltersDifferent(someFilters: Filter[], anotherFilters: Filter[]): boolean;

// Warning: (ae-forgotten-export) The symbol "NextQuery" needs to be exported by the entry point index.d.ts
//
// @public
export function areNextQueriesDifferent(a: NextQuery_2[], b: NextQuery_2[]): boolean;

// @public
export function arrayToObject(array: string[]): Record<string, string>;

// @public
export function arrayToObject<ArrayType, KeyType extends string | number>(array: ArrayType[], key: PropsWithType<ArrayType, KeyType>): Record<string, ArrayType>;

// @public (undocumented)
export const ArrowIcon: {};

// @public
export type ArrowKey = 'ArrowUp' | 'ArrowDown' | 'ArrowRight' | 'ArrowLeft';

// @public (undocumented)
export const BagIcon: {};

// @public
export class Banner extends Vue_2 {
    // Warning: (ae-forgotten-export) The symbol "Banner" needs to be exported by the entry point index.d.ts
    banner: Banner_2;
}

// Warning: (ae-forgotten-export) The symbol "SearchItemsInjectionMixin" needs to be exported by the entry point index.d.ts
//
// @public
export class BannersList extends SearchItemsInjectionMixin {
    protected animation: Vue_2 | string;
    // @internal
    get items(): SearchItem[];
    stateItems: Banner_2[];
}

// @public (undocumented)
export const BarCodeIcon: {};

// @public (undocumented)
export const BarcodeTinyIcon: {};

// @public
export class BaseAddToCart extends Vue_2 {
    protected get events(): Partial<XEventsTypes>;
    // Warning: (ae-forgotten-export) The symbol "Result" needs to be exported by the entry point index.d.ts
    protected result: Result;
}

// Warning: (ae-forgotten-export) The symbol "BaseColumnPickerDropdown_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BaseColumnPickerDropdown extends BaseColumnPickerDropdown_base {
    animation?: string | typeof Vue_2;
    emitEvent(column: number): void;
}

// Warning: (ae-forgotten-export) The symbol "BaseColumnPickerList_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BaseColumnPickerList extends BaseColumnPickerList_base {
    // Warning: (ae-forgotten-export) The symbol "ColumnPickerItem" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected get columnsWithCssClasses(): ColumnPickerItem[];
}

// @public
export class BaseCurrency extends Vue_2 {
    // @internal
    protected get currency(): string;
    protected format?: string;
    injectedFormat: string;
    // @internal
    protected get renderedFormat(): string;
    protected value: number;
}

// @public
export class BaseDropdown extends Vue_2 {
    // (undocumented)
    $refs: {
        itemButtons: HTMLButtonElement[];
    };
    // @internal
    protected addDocumentCloseListeners(): void;
    animation: typeof Vue_2 | string;
    // @internal
    protected beforeDestroy(): void;
    // @internal
    protected close(): void;
    protected closeIfEventIsOutOfDropdown(event: MouseEvent | TouchEvent | FocusEvent): void;
    // @internal
    protected get dropdownCSSClasses(): VueCSSClasses;
    // @internal
    protected emitSelectedItemChanged(item: DropdownItem): void;
    // @internal
    protected focusHighlightedItem(highlightedItemIndex: number): void;
    // @internal
    protected highlightedItemIndex: number;
    // @internal
    protected highlightFirstItem(): void;
    // @internal
    protected highlightLastItem(): void;
    // @internal
    protected highlightMatchingItem(search: string): void;
    // @internal
    protected highlightNextItem(): void;
    // @internal
    protected highlightPreviousItem(): void;
    // @internal
    protected isOpen: boolean;
    // Warning: (ae-forgotten-export) The symbol "DropdownItem" needs to be exported by the entry point index.d.ts
    items: DropdownItem[];
    // @internal
    protected get itemsCSSClasses(): VueCSSClasses[];
    // @internal
    protected open(): void;
    // @internal
    protected removeDocumentCloseListeners(): void;
    // @internal
    protected resetSearch(): void;
    // @internal
    protected restartResetSearchTimeout: () => void;
    // @internal
    protected searchBuffer: string;
    searchTimeoutMs: number;
    // @internal
    protected syncCloseListeners(isOpen: boolean): void;
    // @internal
    protected toggle(): void;
    // @internal
    protected updateHighlightedItem(isOpen: boolean): void;
    // @internal
    protected updateSearchBuffer(event: KeyboardEvent): void;
    // @internal
    protected updateSearchTimeout(searchTimeoutMs: number): void;
    value: DropdownItem | null;
}

// @public
export class BaseEventButton extends Vue_2 {
    // (undocumented)
    protected emitEvents(): void;
    protected events: Partial<XEventsTypes>;
}

// @public
export class BaseEventsModal extends Vue_2 {
    animation?: Vue_2 | string;
    bodyClickEvent: XEvent;
    // @internal
    closeModal(): void;
    protected emitBodyClickEvent(event: MouseEvent | FocusEvent): void;
    eventsToCloseModal: XEvent[];
    eventsToOpenModal: XEvent[];
    protected isOpen: boolean;
    protected openerElement?: HTMLElement;
    // @internal
    openModal(_payload: unknown, metadata: WireMetadata): void;
}

// @public
export class BaseEventsModalClose extends Vue_2 {
    // (undocumented)
    protected closingEvent: PropsWithType<XEventsTypes, void>;
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
}

// @public
export class BaseEventsModalOpen extends Vue_2 {
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
    // (undocumented)
    protected openingEvent: PropsWithType<XEventsTypes, void>;
}

// @public (undocumented)
export const BaseFallbackImage: {};

// @public
export class BaseGrid extends Vue_2 {
    protected animation: Vue_2 | string;
    protected columns: number;
    protected get computedItems(): SearchItem[];
    // @internal
    protected get cssClasses(): VueCSSClasses;
    // @internal
    injectedSearchItems: SearchItem[];
    protected items: SearchItem[];
    // @internal
    protected get itemsWithCSSClass(): {
        item: SearchItem;
        cssClass: VueCSSClasses;
    }[];
    // @internal
    protected get style(): Partial<CSSStyleDeclaration>;
}

// @public
export class BaseHeaderTogglePanel extends Vue_2 {
    protected animation: Vue_2 | string;
    // @internal
    protected emitOpenStatusEvent(): void;
    // @internal
    protected open: boolean;
    protected startCollapsed: boolean;
    // @internal
    protected toggleOpen(): void;
}

// @public
export class BaseIdModal extends Vue_2 {
    animation?: Vue_2 | string;
    closeModal(payload: string): void;
    protected emitClickOutOfModal(event: MouseEvent | FocusEvent): void;
    protected isOpen: boolean;
    modalId: string;
    protected openerElement?: HTMLElement;
    openModal(modalId: string, metadata: WireMetadata): void;
}

// @public
export class BaseIdModalClose extends Vue_2 {
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
    // (undocumented)
    protected modalId: string;
}

// @public
export class BaseIdModalOpen extends Vue_2 {
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
    // (undocumented)
    protected modalId: string;
}

// @public
export class BaseIdScroll extends Vue_2 {
    distanceToBottom: number;
    // @internal
    protected emitEvent<Event extends XEvent>(event: Event): void;
    // @internal
    protected emitEvent<Event extends XEvent>(event: Event, payload: XEventPayload<Event>): void;
    id: string;
    protected resetOnQueryChange: boolean;
    // @internal
    protected scroll(position: number): void;
    // @internal
    protected scrollAlmostAtEnd(distance: number): void;
    // @internal
    protected scrollAtEnd(): void;
    // @internal
    protected scrollAtStart(): void;
    // @internal
    protected scrollDirectionChange(direction: ScrollDirection): void;
    // @internal
    scrollToTop(payload: string): void;
    throttleMs: number;
}

// @public
export class BaseIdTogglePanel extends Vue_2 {
    protected animation: Vue_2;
    created(): void;
    emitStateEvent(): void;
    protected isOpen: boolean;
    panelId: string;
    protected startOpen: boolean;
    togglePanel(panelId: string): void;
}

// @public
export class BaseIdTogglePanelButton extends Vue_2 {
    // @internal
    protected get events(): Partial<XEventsTypes>;
    protected isPanelOpen: boolean;
    protected panelId: string;
    updatePanelState(newState: boolean, { id }: WireMetadata): void;
}

// @public
export class BaseKeyboardNavigation extends Vue_2 {
    protected elementToFocus: HTMLElement | undefined;
    protected eventsForDirectionLimit: Partial<EventsForDirectionLimit>;
    // @internal
    protected focusNextNavigableElement(direction: ArrowKey | KeyboardEvent): void;
    // (undocumented)
    mounted(): void;
    protected navigationHijacker: TakeNavigationControl[];
    protected get navigationHijackerEvents(): XEventsOf<ArrowKey>[];
    protected navigationService: SpatialNavigation;
    triggerNavigation(eventPayload: ArrowKey, metadata: WireMetadata): void;
}

// Warning: (ae-forgotten-export) The symbol "BaseMainScroll_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BaseMainScroll extends BaseMainScroll_base {
    // (undocumented)
    beforeDestroy(): void;
    protected element: HTMLElement;
    // @internal
    protected elementListener: Document | HTMLElement;
    // @internal
    protected emitEvent<Event extends XEvent>(event: Event): void;
    // @internal
    protected emitEvent<Event extends XEvent>(event: Event, payload: XEventPayload<Event>): void;
    protected id: string;
    // @internal
    protected initAndListenElement(): void;
    // (undocumented)
    mounted(): void;
    // (undocumented)
    render(): void;
    // @internal
    protected storeScrollData(): void;
    // Warning: (ae-forgotten-export) The symbol "ScrollableTag" needs to be exported by the entry point index.d.ts
    protected tag: ScrollableTag;
    // @internal
    protected throttledStoreScrollData: ThrottleFunction<[]>;
}

// @public
export class BaseModal extends Vue_2 {
    // (undocumented)
    $refs: {
        modal: HTMLDivElement;
        overlay: HTMLDivElement;
    };
    // @internal
    protected addBodyListeners(): void;
    animation: Vue_2 | string;
    // @internal
    protected disableScroll(): void;
    // @internal
    protected emitFocusInBody(event: FocusEvent): void;
    // @internal
    protected emitOverlayClicked(event: MouseEvent): void;
    // @internal
    protected enableScroll(): void;
    // (undocumented)
    protected mounted(): void;
    open: boolean;
    protected previousBodyOverflow: string;
    protected previousHTMLOverflow: string;
    // @internal
    protected removeBodyListeners(): void;
    // @internal
    protected syncBody(isOpen: boolean): void;
}

// @public (undocumented)
export const BasePlaceholderImage: {};

// @public
export class BasePriceFilterLabel extends Vue_2 {
    filter: {
        range: RangeValue;
    };
    format?: string;
    from: string;
    fromTo: string;
    protected get label(): string;
    lessThan: string;
    // (undocumented)
    render(createElement: CreateElement): VNode;
}

// @public
export class BaseRating extends Vue_2 {
    // @internal
    protected get ariaLabel(): string;
    // @internal
    protected get calculateFilledWrapperWidth(): string;
    protected max: number;
    protected value: number;
}

// @public
export class BaseRatingFilterLabel extends Vue_2 {
    filter: Filter;
    protected max: number;
    // @internal
    protected get value(): number;
}

// @public
export class BaseResultCurrentPrice extends Vue_2 {
    // @internal
    protected get dynamicClasses(): VueCSSClasses;
    protected format?: string;
    protected result: Result;
}

// @public
export class BaseResultImage extends Vue_2 {
    $refs: {
        image: HTMLElement;
    };
    // @internal
    protected createObserver(): void;
    protected failedImages: string[];
    // @internal
    protected flagImageAsFailed(): void;
    // @internal
    protected flagImageLoaded(): void;
    // @internal
    protected get hasAllImagesFailed(): boolean;
    protected hasEnteredView: boolean;
    protected hasImageLoaded: boolean;
    // @internal
    protected get imageSrc(): string;
    // @internal
    protected get isIntersectionObserverAvailable(): boolean;
    // (undocumented)
    mounted(): void;
    // @internal
    protected observerHandler(entries: IntersectionObserverEntry[], observer: IntersectionObserver): void;
    protected result: Result;
}

// @public
export class BaseResultLink extends Vue_2 {
    emitUserClickedAResult(): void;
    emitUserRightClickedAResult(): void;
    protected metadata: Omit<WireMetadata, 'moduleName'>;
    // (undocumented)
    mounted(): void;
    protected origin: QueryOrigin;
    protected result: Result;
    protected resultClickExtraEvents: PropsWithType<XEventsTypes, Result>[];
}

// @public
export class BaseResultPreviousPrice extends Vue_2 {
    protected format: string;
    protected result: Result;
}

// Warning: (ae-forgotten-export) The symbol "BaseScroll_base" needs to be exported by the entry point index.d.ts
//
// @public
export class BaseScroll extends BaseScroll_base {
    // (undocumented)
    mounted(): void;
    protected resetOnQueryChange: boolean;
    // @internal
    scrollToTop(): void;
    // @internal
    protected storeScrollData(): void;
    // @internal
    protected throttledStoreScrollData: ThrottleFunction<[]>;
}

// @public
export class BaseScrollToTop extends Vue_2 {
    animation: Vue_2 | string;
    // @internal
    enableHasAlmostReachedScrollEnd(_payload: unknown, metadata: WireMetadata): void;
    // @internal
    protected get events(): Partial<XEventsTypes>;
    // @internal
    protected hasAlmostReachedScrollEnd: boolean;
    // @internal
    protected isThisScroll(id?: string): boolean;
    // @internal
    protected get isThresholdReached(): boolean;
    // @internal
    protected get isVisible(): boolean;
    // @internal
    protected scrollDirection: ScrollDirection;
    scrollId?: string;
    // @internal
    protected scrollTop: number;
    // @internal
    storeScrollDirection(scrollDirection: ScrollDirection, metadata: WireMetadata): void;
    // @internal
    storeScrollPosition(scrollPosition: number, metadata: WireMetadata): void;
    thresholdPx?: number;
    // @internal
    updateHasAlmostReachedScrollEnd(scrollDirection: ScrollDirection): void;
    // @internal
    protected get useThresholdStrategy(): boolean;
}

// @public
export class BaseSuggestion extends Vue_2 {
    protected get dynamicCSSClasses(): VueCSSClasses;
    protected get events(): Partial<XEventsTypes>;
    // @internal
    protected get hasMatchingQuery(): boolean;
    protected query: string;
    protected get queryHTML(): string;
    // @internal
    protected splitAt(label: string, start: number, skip: number): [string, string, string];
    // Warning: (ae-forgotten-export) The symbol "Suggestion" needs to be exported by the entry point index.d.ts
    protected suggestion: Suggestion;
    protected suggestionSelectedEvents: Partial<XEventsTypes>;
}

// @public
export class BaseSuggestions extends Vue_2 {
    protected animation: Vue_2 | string;
    // @internal
    protected getFacetKey(facet: Facet): string;
    // Warning: (ae-forgotten-export) The symbol "Facet" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected getFacetsKey(facets: Facet[]): string;
    protected suggestions: Suggestion[];
    // @internal
    protected get suggestionsKeys(): string[];
}

// @public
export class BaseTogglePanel extends Vue_2 {
    protected animation: Vue_2 | string;
    protected open: boolean;
}

// @public
export class BaseVariableColumnGrid extends Vue_2 {
    protected animation: Vue_2 | string;
    // @internal
    protected columns: number;
    protected items?: SearchItem[];
    // @internal
    setColumns(newColumns: number): void;
}

// @public
export class BaseXAPI implements XAPI {
    // @internal
    protected bus: XBus;
    init(config: SnippetConfig): void;
    // @internal
    protected initCallback: (config: SnippetConfig) => any;
    // @internal
    protected isXInitialized: boolean;
    search(query?: string): void;
    // @internal
    setBus(bus: XBus): void;
    setInitCallback(initCallback: (config: SnippetConfig) => any): void;
}

// @public
export class BaseXBus implements XBus {
    emit<Event extends XEvent>(event: Event, payload?: XEventPayload<Event>, metadata?: WireMetadata): void;
    // @internal
    protected emitters: Emitters;
    // @internal
    protected getOrCreateEmitter<Event extends XEvent>(event: Event): Emitter<Event>;
    on<Event extends XEvent>(event: Event, withMetadata?: boolean): Observable<WirePayload<XEventPayload<Event>> | XEventPayload<Event>>;
}

// @internal
export const bus: XBus;

// @public
export const cancelFetchAndSaveIdentifierResults: () => void;

// @public
export const cancelFetchAndSaveIdentifierResultsWire: AnyWire;

// @public
export const cancelFetchAndSaveNextQueries: () => void;

// @public
export const cancelFetchAndSavePopularSearches: () => void;

// @public
export const cancelFetchAndSaveQuerySuggestions: () => void;

// @public
export const cancelFetchAndSaveRecommendations: () => void;

// @public
export const cancelFetchAndSaveRelatedTags: () => void;

// @public
export const cancelFetchAndSaveRelatedTagsWire: AnyWire;

// @public
export const cancelFetchAndSaveSearchResponse: () => void;

// @public
export const cancelFetchAndSaveSearchResponseWire: AnyWire;

// @public
export const cancelFetchAndSaveSuggestionsWire: AnyWire;

// @internal
export function cancellablePromise<T, K = unknown>(promise: Promise<T>, cancelCallback?: (payload?: K) => void): CancellablePromiseFunction<T, K>;

// @internal
export interface CancellablePromiseFunction<T, K = unknown> {
    cancel: (payload?: K) => void;
    promise: Promise<T>;
}

// @internal
export const CancelSymbol: unique symbol;

// @public (undocumented)
export const CartIcon: {};

// @public (undocumented)
export const CheckboxCardSelectedIcon: {};

// @public (undocumented)
export const CheckboxCardUnselectedIcon: {};

// @public (undocumented)
export const CheckboxSelectedIcon: {};

// @public (undocumented)
export const CheckboxUnselectedIcon: {};

// @public (undocumented)
export const CheckIcon: {};

// @public (undocumented)
export const CheckTinyIcon: {};

// @public (undocumented)
export const ChevronDownIcon: {};

// @public (undocumented)
export const ChevronLeftIcon: {};

// @public (undocumented)
export const ChevronRightIcon: {};

// @public (undocumented)
export const ChevronTinyDownIcon: {};

// @public (undocumented)
export const ChevronTinyLeftIcon: {};

// @public (undocumented)
export const ChevronTinyRightIcon: {};

// @public (undocumented)
export const ChevronTinyUpIcon: {};

// @public (undocumented)
export const ChevronUpIcon: {};

// @public
export function cleanUndefined<T>(obj: T): T;

// @public
export class ClearHistoryQueries extends Vue_2 {
    // @internal
    protected clearHistoryQueriesEvents: Partial<XEventsTypes>;
    // @internal
    protected get dynamicClasses(): VueCSSClasses;
    // @internal
    historyQueries: HistoryQuery_2[];
    // @internal
    protected get isHistoryQueriesEmpty(): boolean;
}

// @public
export const clearHistoryQueries: AnyWire;

// @public
export const clearHistoryQueriesQuery: AnyWire;

// @public
export const clearIdentifierResultsQuery: AnyWire;

// @public
export const clearNoSuggestionsQuery: AnyWire;

// @public
export const clearQuerySuggestionsQuery: AnyWire;

// @public
export const clearRelatedTagsQuery: AnyWire;

// @public
export class ClearSearchInput extends Vue_2 {
    // @internal
    protected clearSearchInputEvents: Partial<XEventsTypes>;
    // (undocumented)
    protected get dynamicClasses(): VueCSSClasses;
    // (undocumented)
    protected get isQueryEmpty(): boolean;
    // (undocumented)
    query: string;
}

// @public
export const clearSelectedRelatedTags: AnyWire;

// @public
export function clone<Something>(something: Something): Something;

// @public
export class CollapseFromTop extends Vue_2 {
}

// @public
export class CollapseHeight extends Vue_2 {
}

// @public
export class CollapseWidth extends Vue_2 {
}

// @public
export class ColumnPickerMixin extends Vue_2 {
    // @internal
    beforeMount(): void;
    protected columns: number[];
    // @internal
    protected emitChange(column: number): void;
    // @internal
    get providedSelectedColumns(): number;
    // @internal
    selectedColumns: number;
    // @internal
    setSelectedColumns(columns: number): void;
    protected value?: number;
}

// @public
export function compileMessage(message: string, params: Dictionary<string | number>): string;

// Warning: (ae-forgotten-export) The symbol "AnimatedProperty" needs to be exported by the entry point index.d.ts
//
// @public
export function createCollapseAnimationMixin(property: AnimatedProperty): ComponentOptions<Vue_2>;

// @public
export function createStoreEmitters<Module extends AnyXStoreModule, Emitters extends StoreEmitters<Module>>(storeModule: Module, emitters: Emitters): Emitters;

// @public
export function createWireFromFunction<Payload>(fn: (parameters: WireParams<Payload>) => void): Wire<Payload>;

// @public
export function createWiring<T extends Partial<Wiring>>(wiring: T): T;

// @internal
export const createXComponentAPIMixin: (bus: XBus) => ComponentOptions<Vue_2> & ThisType<Vue_2 & {
    xComponent: XComponent | undefined;
}>;

// @public (undocumented)
export const CrossIcon: {};

// @public (undocumented)
export const CrossTinyIcon: {};

// @public
export function currencyFormatter(value: number, format?: string): string;

// @public
export function Debounce(debounceTimeInMs: number, debounceOptions?: DebounceOptions): DecoratorFor<AnyFunction>;

// @public
export function debounce<Payload>(wire: Wire<Payload>, timeInMs: TimeRetrieving | number, raceEvent?: XEvent | XEvent[]): Wire<Payload>;

// @public
export interface DebouncedFunction<Params extends any[]> {
    // (undocumented)
    (...args: Params): void;
    // (undocumented)
    cancel(): void;
}

// @public
export const debounceFunction: <Params extends any[]>(fn: (...args: Params) => void, debounceTimeInMs: number, { leading, trailing }?: DebounceOptions) => DebouncedFunction<Params>;

// @public
export interface DebounceOptions {
    // (undocumented)
    leading?: boolean;
    // (undocumented)
    trailing?: boolean;
}

// @public
export type DecoratorFor<Type> = <Key extends string, Target extends Record<Key, Type>>(target: Target, key: Key) => void;

// @public
export function deepFilter<ArrayType, Key extends PropsWithType<ArrayType, ArrayType[]>>(array: ArrayType[], filter: (item: ArrayType) => boolean, childrenKey: Key): ArrayType[];

// @public
export function deepFlat<ArrayType, Key extends PropsWithType<ArrayType, ArrayType[] | undefined>>(array: ArrayType[], childrenKey: Key): ArrayType[];

// @public
export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends NonPrimitive ? T[P] extends AnyFunction ? T[P] : DeepPartial<T[P]> : T[P];
};

// @public
export class DefaultFacetsService implements FacetsService {
    // (undocumented)
    clearFilters(facetIds?: Array<Facet['id']>): void;
    // Warning: (ae-forgotten-export) The symbol "FilterEntity" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected createEntity(filter: Filter): FilterEntity;
    // (undocumented)
    deselect(filter: Filter): void;
    // @internal
    protected getSelectedFilters(): FacetsGetters['selectedFilters'];
    static instance: FacetsService;
    // @internal
    protected removeFacet(facet: Omit<Facet, 'filters'>): void;
    // @internal
    protected removeFilter(filter: Filter): void;
    // @internal
    protected removeGroupFacets(groupId: FacetsGroup['id']): Omit<Facet, 'filters'>[];
    // @internal
    protected removeGroupFilters(groupId: FacetsGroup['id']): Filter[];
    protected saveFiltersWithPreviousState(newFilters: Filter[], previousFilters: Filter[]): void;
    // (undocumented)
    select(filter: Filter): void;
    // @internal
    protected setFacet({ filters, ...restFacet }: Facet): void;
    // @internal
    protected setFacetGroup(facetGroup: FacetGroupEntry): void;
    // (undocumented)
    setFacets(facetsGroup: FacetsGroup): void;
    // (undocumented)
    protected get store(): Store<RootXStoreState>;
    // (undocumented)
    toggle(filter: Filter): void;
    // (undocumented)
    updateFacets(facetsGroup: FacetsGroup): void;
}

// @public
export interface DeviceActions {
}

// @public
export class DeviceDetector extends Vue_2 {
    // Warning: (ae-forgotten-export) The symbol "Device" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "MaxWidth" needs to be exported by the entry point index.d.ts
    readonly breakpoints: Record<Device, MaxWidth>;
    // @internal
    get detectedDevice(): string | null;
    readonly force?: Device;
    // @internal
    mounted(): void;
    // @internal
    protected get sortedBreakpoints(): [Device, MaxWidth][];
    // @internal
    protected storeWindowWidth(): void;
    // @internal
    protected throttledStoreWindowWidth: () => void;
    readonly throttleMs: number;
    // @internal
    protected updateThrottledStoreWindowWidth(throttleMs: number): void;
    // @internal
    protected windowWidthPx: number | null;
}

// @internal
export const deviceEmitters: {};

// @public
export interface DeviceGetters {
}

// @public
export interface DeviceMutations {
    setName(device: string | null): void;
}

// @public
export interface DeviceState {
    name: string | null;
}

// @internal
export const deviceWiring: {
    DeviceProvided: {
        setName: Wire<string | null>;
    };
};

// @public
export interface DeviceXEvents {
    DeviceProvided: string | null;
}

// @public
export type DeviceXModule = XModule<DeviceXStoreModule>;

// @public
export const deviceXModule: DeviceXModule;

// @public
export type DeviceXStoreModule = XStoreModule<DeviceState, DeviceGetters, DeviceMutations, DeviceActions>;

// @internal
export const deviceXStoreModule: DeviceXStoreModule;

// @public
export type Dictionary<T = any> = Record<string, T>;

// @public
export class DirectionalFocusNavigationService implements SpatialNavigation {
    constructor(
    container: HTMLElement,
    focusableSelectors?: string);
    navigateTo(arrowKey: ArrowKey): HTMLElement;
}

// @public
export type DocumentDirection = 'ltr' | 'rtl';

// @public
export type Emitter<Event extends XEvent> = Subject<WirePayload<XEventPayload<Event>>>;

// @public
export type Emitters = {
    [Event in XEvent]?: Emitter<Event>;
};

// @public
export class Empathize extends Vue_2 {
    protected animation: Vue_2;
    // @internal
    changeOpenState(newOpenState: boolean, metadata: WireMetadata): void;
    // @internal
    close(payload: unknown, metadata: WireMetadata): void;
    protected eventsToCloseEmpathize: XEvent[];
    protected eventsToOpenEmpathize: XEvent[];
    // @internal
    protected isOpen: boolean;
    // @internal
    open(payload: unknown, metadata: WireMetadata): void;
}

// @public
export interface EmpathizeActions {
}

// @public
export interface EmpathizeConfig {
}

// @internal
export const empathizeEmitters: {};

// @public
export interface EmpathizeGetters {
}

// @public
export interface EmpathizeMutations {
    setIsOpen(isOpen: boolean): void;
}

// @public
export interface EmpathizeState {
    config: EmpathizeConfig;
    isOpen: boolean;
}

// @internal
export const empathizeWiring: {
    EmpathizeOpened: {
        setIsOpen: AnyWire;
    };
    EmpathizeClosed: {
        setIsNotOpen: AnyWire;
    };
};

// @public
export interface EmpathizeXEvents {
    EmpathizeClosed: void;
    EmpathizeOpened: void;
    UserClosedEmpathize: void;
}

// @public
export type EmpathizeXModule = XModule<EmpathizeXStoreModule>;

// @public
export const empathizeXModule: EmpathizeXModule;

// @public
export type EmpathizeXStoreModule = XStoreModule<EmpathizeState, EmpathizeGetters, EmpathizeMutations, EmpathizeActions>;

// @internal
export const empathizeXStoreModule: EmpathizeXStoreModule;

// @public
export type EventsForDirectionLimit = {
    [key in ArrowKey]: PropsWithType<XEventsTypes, void>;
};

// @public
export type ExtractActionPayload<ModuleName extends XModuleName, ActionName extends ActionNamesFor<ModuleName>> = ExtractPayload<ExtractActions<XModulesTree[ModuleName]>[ActionName]>;

// @public
export type ExtractActionReturn<Action extends (payload?: any) => any> = ReturnType<Action> extends Promise<any> ? ReturnType<Action> : Promise<ReturnType<Action>>;

// @public
export type ExtractActions<Module extends AnyXModule> = Module extends XModule<XStoreModule<any, any, any, infer Actions>> ? Actions : never;

// @public
export type ExtractGetters<Module extends XModuleName> = XModulesTree[Module] extends XModule<XStoreModule<any, infer Getter, any, any>> ? Getter : never;

// @public
export type ExtractMutationPayload<ModuleName extends XModuleName, MutationName extends MutationNamesFor<ModuleName>> = ExtractPayload<ExtractMutations<XModulesTree[ModuleName]>[MutationName]>;

// @public
export type ExtractMutations<Module extends AnyXModule> = Module extends XModule<XStoreModule<any, any, infer Mutations, any>> ? Mutations : never;

// @public
export type ExtractPayload<SomeFunction> = SomeFunction extends (payload?: any) => any ? Parameters<SomeFunction>[0] : never;

// @public
export type ExtractState<Module extends XModuleName> = XModulesTree[Module] extends XModule<XStoreModule<infer State, any, any, any>> ? State : never;

// @public
export class ExtraParams extends Vue_2 {
    // (undocumented)
    render(): void;
    values: Dictionary<unknown>;
}

// @public
export interface ExtraParamsActions {
}

// @internal
export const extraParamsEmitters: {
    ExtraParamsChanged: (state: ExtraParamsState) => Dictionary<unknown>;
};

// @public
export interface ExtraParamsGetters {
}

// @public
export interface ExtraParamsMutations {
    // (undocumented)
    setParams(params: Dictionary<unknown>): void;
}

// @public
export interface ExtraParamsState {
    // (undocumented)
    params: Dictionary<unknown>;
}

// @internal
export const extraParamsWiring: {
    UserChangedExtraParams: {
        setExtraParams: Wire<Dictionary<unknown>>;
    };
    ExtraParamsProvided: {
        setExtraParams: Wire<Dictionary<unknown>>;
    };
};

// @public
export interface ExtraParamsXEvents {
    // (undocumented)
    ExtraParamsChanged: Dictionary<unknown>;
    // (undocumented)
    ExtraParamsProvided: Dictionary<unknown>;
    // (undocumented)
    UserChangedExtraParams: Dictionary<unknown>;
}

// @public
export type ExtraParamsXModule = XModule<ExtraParamsXStoreModule>;

// @public
export const extraParamsXModule: ExtraParamsXModule;

// @public
export type ExtraParamsXStoreModule = XStoreModule<ExtraParamsState, ExtraParamsGetters, ExtraParamsMutations, ExtraParamsActions>;

// @internal
export const extraParamsXStoreModule: ExtraParamsXStoreModule;

// @public
export interface ExtraPluginsOptions {
    bus: XBus;
    snippet: SnippetConfig;
    vue: VueConstructor;
}

// @public
export interface FacetGroupEntry {
    facetId: Facet['id'];
    groupId: GroupId;
}

// @public
export interface FacetsActions {
}

// @public
export type FacetsActionsContext = XActionContext<FacetsState, FacetsGetters, FacetsMutations, FacetsActions>;

// @internal
export const facetsEmitters: {
    SelectedFiltersChanged: {
        selector: (_: FacetsState, getters: Returns<GettersTree<FacetsState, FacetsGetters>>) => Filter[];
        filter: typeof areFiltersDifferent;
    };
    FacetsQueryChanged: {
        selector: (state: FacetsState) => string;
        filter: typeof isNewQuery;
    };
};

// @public
export interface FacetsGetters {
    facets: Record<Facet['id'], Facet>;
    selectedFilters: Filter[];
    selectedFiltersByFacet: FiltersByFacet;
}

// @public
export interface FacetsGroup {
    facets: Facet[];
    id: string;
}

// @public
export interface FacetsMutations {
    removeFacet(facet: Facet): void;
    removeFilter(filter: Filter): void;
    setFacet(facet: Facet): void;
    setFacetGroup(facetGroupEntry: FacetGroupEntry): void;
    setFilter(filter: Filter): void;
    setQuery(query: string): void;
}

// @public
export interface FacetsService {
    clearFilters(facetIds?: Array<Facet['id']>): void;
    deselect(filter: Filter): void;
    select(filter: Filter): void;
    setFacets(facetsGroup: FacetsGroup): void;
    toggle(filter: Filter): void;
    updateFacets(facetsGroup: FacetsGroup): void;
}

// @public
export interface FacetsState {
    facets: Record<Facet['id'], Omit<Facet, 'filters'>>;
    filters: Record<Filter['id'], Filter>;
    groups: Record<Facet['id'], GroupId>;
    query: string;
}

// @internal
export const facetsWiring: {
    FacetsChanged: {
        updateFacetsGroupWithSearchFacetsWire: Wire<Facet[]>;
    };
    FacetsGroupProvided: {
        setFacetsGroupWire: Wire<FacetsGroup>;
    };
    UserClickedAFilter: {
        toggleFilterWire: Wire<Filter>;
    };
    UserClickedClearAllFilters: {
        clearFiltersWire: Wire<(string | number)[] | undefined>;
    };
    UserModifiedEditableNumberRangeFilter: {
        selectFilterWire: Wire<Filter>;
    };
    UserClickedAllFilter: {
        clearFiltersWire: Wire<(string | number)[] | undefined>;
    };
    UserAcceptedAQuery: {
        setFacetsQuery: Wire<string>;
    };
    UserClearedQuery: {
        setFacetsQuery: Wire<string>;
    };
    FacetsQueryChanged: {
        clearAllFiltersWire: AnyWire;
    };
};

// @public
export type FacetsXModule = XModule<FacetsXStoreModule>;

// @public
export const facetsXModule: FacetsXModule;

// @public
export type FacetsXStoreModule = XStoreModule<FacetsState, FacetsGetters, FacetsMutations, FacetsActions>;

// @internal
export const facetsXStoreModule: FacetsXStoreModule;

// @public
export class FadeAndSlide extends Vue_2 {
    protected tag: string;
}

// @public
export const fetchAndSaveIdentifierResults: (context: IdentifierResultsActionsContext) => void | Promise<void>;

// @public
export const fetchAndSaveIdentifierResultsWire: AnyWire;

// @public
export const fetchAndSaveNextQueries: (context: NextQueriesActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveNextQueriesWire: AnyWire;

// @public
export const fetchAndSavePopularSearches: (context: PopularSearchesActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveQuerySuggestions: (context: QuerySuggestionsActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveRecommendations: (context: RecommendationsActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveRelatedTags: (context: RelatedTagsActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveRelatedTagsWire: AnyWire;

// @public
export const fetchAndSaveSearchResponse: (context: SearchActionContext) => void | Promise<void>;

// @public
export const fetchAndSaveSearchResponseWire: AnyWire;

// @public
export const fetchAndSaveSuggestionsWire: AnyWire;

// @public
export const fetchIdentifierResults: IdentifierResultsXStoreModule['actions']['fetchIdentifierResults'];

// @public
export const fetchNextQueries: NextQueriesXStoreModule['actions']['fetchNextQueries'];

// @public
export const fetchPopularSearches: PopularSearchesXStoreModule['actions']['fetchSuggestions'];

// @public
export const fetchQuerySuggestions: QuerySuggestionsXStoreModule['actions']['fetchSuggestions'];

// @public
export const fetchRecommendations: RecommendationsXStoreModule['actions']['fetchRecommendations'];

// @public
export const fetchRelatedTags: RelatedTagsXStoreModule['actions']['fetchRelatedTags'];

// @public
export const fetchSearchResponse: SearchXStoreModule['actions']['fetchSearchResponse'];

// @public
export function filter<Payload>(wire: Wire<Payload>, filterFn: (parameters: WireParams<Payload>) => boolean): Wire<Payload>;

// @public
export function filterBlacklistedModules<Payload>(wire: Wire<Payload>, blacklist: Array<XModuleName | null>): Wire<Payload>;

// @public
export function filterFalsyPayload<Payload>(wire: Wire<Payload>): Wire<Payload>;

// @public
export type FiltersByFacet = Record<Facet['id'], Filter[]>;

// @public (undocumented)
export const FiltersIcon: {};

// @public
export function filterTruthyPayload<Payload>(wire: Wire<Payload>): Wire<Payload>;

// @public
export function filterWhitelistedModules<Payload>(wire: Wire<Payload>, whitelist: Array<XModuleName | null>): Wire<Payload>;

// @public
export type FirstParameter<SomeFunction extends AnyFunction> = Parameters<SomeFunction>[0];

// @public
export function forEach<T extends Dictionary>(obj: T | undefined | null, callbackFn: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => void): void;

// @internal
export function getBusAPI(bus: XBus, xComponent: XComponent | undefined): XComponentBusAPI;

// @public
export function getRootXComponent(component: Vue_2): XComponent | undefined;

// @public
export function getStateAndGettersFromModule<ModuleName extends XModuleName>(state: RootXStoreState, getters: Pick<Store<any>, 'getters'>, moduleName: ModuleName): StoreModuleStateAndGetters<ModuleName>;

// @public
export function Getter<Module extends XModuleName, GetterName extends keyof ExtractGetters<Module>>(module: Module, getter: GetterName): DecoratorFor<ExtractGetters<Module>[GetterName]>;

// @public
export type GettersClass<Module extends AnyXStoreModule> = Partial<Module['getters']>;

// @public
export type GettersTree<State extends Dictionary, Getters extends Dictionary> = {
    [Key in keyof Getters]: (state: State, getters: Getters, rootState: RootXStoreState, rootGetters: any) => Getters[Key];
};

// @public
export const getURLParameter: (param: string) => string | null;

// @internal
export function getXComponentXModuleName(component: Vue_2): XModuleName | null;

// @public (undocumented)
export const Grid1ColIcon: {};

// @public (undocumented)
export const Grid2ColIcon: {};

// @public
export type GroupId = string;

// @public
export function groupItemsBy<ArrayType, ReturnType extends string | number>(array: ArrayType[], groupBy: (item: ArrayType) => ReturnType): Record<ReturnType, ArrayType[]>;

// @public (undocumented)
export const HideIcon: {};

// @public (undocumented)
export const HistoryIcon: {};

// @public
export class HistoryQueries extends Vue_2 {
    protected animation: Vue_2;
    // (undocumented)
    protected get historyQueries(): HistoryQuery_2[];
    protected maxItemsToRender?: number;
    // @internal
    storedHistoryQueries: HistoryQuery_2[];
}

// @public
export const historyQueries: ({ query, historyQueries, config }: HistoryQueriesState) => HistoryQuery_2[];

// @public
export type HistoryQueriesActionContext = XActionContext<HistoryQueriesState, HistoryQueriesGetters, HistoryQueriesMutations, HistoryQueriesActions>;

// @public
export interface HistoryQueriesActions {
    addQueryToHistory(query: string): void;
    loadHistoryQueriesFromBrowserStorage(): void;
    refreshSession(): void;
    removeFromHistory(historyQuery: HistoryQuery_2): void;
    setHistoryQueries(historyQueries: HistoryQuery_2[]): void;
}

// @public
export interface HistoryQueriesConfig {
    debounceInMs: number;
    hideIfEqualsQuery: boolean;
    maxItemsToStore: number;
    sessionTTLInMs: number;
}

// @internal
export const historyQueriesEmitters: {
    SessionHistoryQueriesChanged: (_state: HistoryQueriesState, getters: Returns<GettersTree<HistoryQueriesState, HistoryQueriesGetters>>) => HistoryQuery_2[];
    HistoryQueriesQueryChanged: {
        immediate: true;
        selector: (state: HistoryQueriesState) => string;
    };
    HistoryQueriesStorageKeyChanged: {
        immediate: true;
        selector: (_state: HistoryQueriesState, getters: Returns<GettersTree<HistoryQueriesState, HistoryQueriesGetters>>) => string;
    };
};

// @public
export class HistoryQueriesGetter implements GettersClass<HistoryQueriesXStoreModule> {
    historyQueries({ query, historyQueries, config }: HistoryQueriesState): HistoryQuery_2[];
    // @internal
    protected searchInHistoryQueries(normalizedQuery: string, hideIfEqualsQuery: boolean): (historyQuery: HistoryQuery_2) => boolean;
}

// @public
export interface HistoryQueriesGetters {
    historyQueries: HistoryQuery_2[];
    normalizedQuery: string;
    sessionHistoryQueries: HistoryQuery_2[];
    storageKey: string;
}

// @public
export interface HistoryQueriesMutations {
    setHistoryQueries(historyQueries: HistoryQuery_2[]): void;
    setQuery(query: string): void;
    setSessionTimeStamp(timeStamp: number): void;
}

// @public
export interface HistoryQueriesState {
    config: HistoryQueriesConfig;
    historyQueries: HistoryQuery_2[];
    query: string;
    sessionTimeStampInMs: number;
}

// @internal
export const historyQueriesWiring: {
    HistoryQueriesQueryChanged: {
        refreshHistoryQueriesSession: AnyWire;
    };
    HistoryQueriesStorageKeyChanged: {
        loadHistoryQueriesFromBrowserStorageWire: AnyWire;
    };
    UserClearedQuery: {
        clearHistoryQueriesQuery: AnyWire;
    };
    UserAcceptedAQuery: {
        setHistoryQueriesQuery: Wire<string>;
        addQueryToHistoryQueries: Wire<string>;
    };
    UserIsTypingAQuery: {
        setHistoryQueriesQueryDebounce: AnyWire;
    };
    UserPressedClearHistoryQueries: {
        clearHistoryQueries: AnyWire;
    };
    UserPressedRemoveHistoryQuery: {
        removeHistoryQuery: Wire<HistoryQuery_2>;
    };
};

// @public
export interface HistoryQueriesXEvents {
    HistoryQueriesDisplayed: HistoryQuery_2[];
    HistoryQueriesQueryChanged: string;
    HistoryQueriesStorageKeyChanged: string;
    SessionHistoryQueriesChanged: HistoryQuery_2[];
    UserPressedClearHistoryQueries: void;
    UserPressedRemoveHistoryQuery: HistoryQuery_2;
    UserSelectedAHistoryQuery: HistoryQuery_2;
}

// @public
export type HistoryQueriesXModule = XModule<HistoryQueriesXStoreModule>;

// @public
export const historyQueriesXModule: HistoryQueriesXModule;

// @public
export type HistoryQueriesXStoreModule = XStoreModule<HistoryQueriesState, HistoryQueriesGetters, HistoryQueriesMutations, HistoryQueriesActions>;

// @internal
export const historyQueriesXStoreModule: HistoryQueriesXStoreModule;

// @public
export class HistoryQuery extends Vue_2 {
    // @internal
    query: string;
    protected suggestion: HistoryQuery_2;
    // @internal
    protected get suggestionSelectedEvents(): Partial<XEventsTypes>;
}

// @public (undocumented)
export const HistoryTinyIcon: {};

// @public
export const identifierDetectionRegexp: IdentifierResultsXStoreModule['getters']['identifierDetectionRegexp'];

// @public
export const identifierHighlightRegexp: IdentifierResultsXStoreModule['getters']['identifierHighlightRegexp'];

// @public
export class IdentifierResult extends Vue_2 {
    protected get highlightedQueryHTML(): string;
    identifierHighlightRegexp: RegExp;
    query: string;
    protected result: Result;
}

// @public
export class IdentifierResults extends Vue_2 {
    protected animation: Vue_2;
    identifierResults: Result[];
}

// @public
export interface IdentifierResultsActions {
    cancelFetchAndSaveIdentifierResults(): void;
    fetchAndSaveIdentifierResults(): void;
    fetchIdentifierResults(): Result[];
    saveQuery(query: string): void;
}

// @public
export type IdentifierResultsActionsContext = XActionContext<IdentifierResultsState, IdentifierResultsGetters, IdentifierResultsMutations, IdentifierResultsActions>;

// @public
export interface IdentifierResultsConfig {
    debounceInMs: number;
    identifierDetectionRegexp: string;
    maxItemsToRequest: number;
    separatorChars: string;
}

// @internal
export const identifierResultsEmitters: {
    IdentifierResultsChanged: (state: IdentifierResultsState) => Result[];
    IdentifierResultsRequestChanged: (_: IdentifierResultsState, getters: Returns<GettersTree<IdentifierResultsState, IdentifierResultsGetters>>) => SearchByIdRequest | null;
};

// @public
export interface IdentifierResultsGetters {
    identifierDetectionRegexp: RegExp;
    identifierHighlightRegexp: RegExp;
    identifierResultsRequest: SearchByIdRequest | null;
}

// Warning: (ae-forgotten-export) The symbol "StatusMutations" needs to be exported by the entry point index.d.ts
//
// @public
export interface IdentifierResultsMutations extends StatusMutations {
    setIdentifierResults(identifierResults: Result[]): void;
    setQuery(newQuery: string): void;
}

// @public
export const identifierResultsRequest: IdentifierResultsXStoreModule['getters']['identifierResultsRequest'];

// Warning: (ae-forgotten-export) The symbol "StatusState" needs to be exported by the entry point index.d.ts
//
// @public
export interface IdentifierResultsState extends StatusState {
    config: IdentifierResultsConfig;
    identifierResults: Result[];
    query: string;
}

// @internal
export const identifierResultsWiring: {
    UserIsTypingAQuery: {
        setIdentifierResultsQueryDebounce: AnyWire;
    };
    UserAcceptedAQuery: {
        setIdentifierResultsQuery: Wire<string>;
    };
    UserClearedQuery: {
        clearIdentifierResultsQuery: AnyWire;
        cancelFetchAndSaveIdentifierResultsWire: AnyWire;
    };
    IdentifierResultsRequestChanged: {
        fetchAndSaveIdentifierResultsWire: AnyWire;
    };
};

// @public
export interface IdentifierResultsXEvents {
    IdentifierResultsChanged: Result[];
    IdentifierResultsRequestChanged: SearchByIdRequest | null;
    UserClickedAIdentifierResult: Result;
}

// @public
export type IdentifierResultsXModule = XModule<IdentifierResultsXStoreModule>;

// @public
export const identifierResultsXModule: IdentifierResultsXModule;

// @public
export type IdentifierResultsXStoreModule = XStoreModule<IdentifierResultsState, IdentifierResultsGetters, IdentifierResultsMutations, IdentifierResultsActions>;

// @internal
export const identifierResultsXStoreModule: IdentifierResultsXStoreModule;

// @public
export const increasePageAppendingResults: AnyWire;

// @public
export interface InfiniteScroll {
    // (undocumented)
    onInfiniteScrollEnd: () => void;
}

// @public
export const infiniteScroll: DirectiveOptions;

// @public
export interface InstallXOptions<API extends XAPI = XAPI> extends XPluginOptions {
    api?: API | false;
    app?: VueConstructor | ComponentOptions<Vue>;
    bus?: XBus;
    domElement?: Element | string;
    installExtraPlugins?(options: ExtraPluginsOptions): VueConstructorPartialArgument | Promise<VueConstructorPartialArgument>;
    plugin?: PluginObject<XPluginOptions>;
    vue?: VueConstructor;
    vueOptions?: VueConstructorPartialArgument;
}

// @internal
export interface Intersection {
    // (undocumented)
    area: number;
    // (undocumented)
    height: number;
    // (undocumented)
    width: number;
}

// @public
export function isArrayEmpty(array: unknown[] | undefined | null): array is undefined | null | [];

// @public
export function isElementEqualOrContained(a: Element, b: Element): boolean;

// @public
export function isInRange(number: number, [min, max]: [number, number]): boolean;

// @public
export function isStringEmpty(str?: string | null): boolean;

// @public
export function isXComponent(component: Vue_2): component is XComponent;

// @public
export class Layout extends Vue_2 {
    protected asideAnimation: Vue_2;
    protected devMode: boolean;
    protected empathizeAnimation: Vue_2;
    // @internal
    protected hasContent(slot: VNode[] | undefined): boolean;
    // @internal
    protected get renderConditions(): {};
}

// @public
export const loadHistoryQueriesFromBrowserStorage: HistoryQueriesXStoreModule['actions']['loadHistoryQueriesFromBrowserStorage'];

// @public
export const loadHistoryQueriesFromBrowserStorageWire: AnyWire;

// @internal
export const localStorageService: StorageService | {
    clear: typeof noOp;
    getItem: typeof noOp;
    setItem: typeof noOp;
    removeItem: typeof noOp;
};

// @public
export function map<T extends Dictionary, W>(obj: T | undefined | null, mapper: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => W): Record<keyof T, W>;

// @public
export function mapWire<FromPayload, ToPayload>(toWire: Wire<ToPayload>, mapFn: (payload: FromPayload) => ToPayload): Wire<FromPayload>;

// @public (undocumented)
export const MenuIcon: {};

// @public (undocumented)
export const MinusIcon: {};

// @public (undocumented)
export const MinusTinyIcon: {};

// @public
export type MonadicFunction = (someParam: any) => any;

// @public
export type MutationNamesFor<ModuleName extends XModuleName> = keyof ExtractMutations<XModulesTree[ModuleName]>;

// @public
export type MutationsDictionary<Mutations> = Record<keyof Mutations, (payload?: any) => void>;

// @public
export type MutationsTree<State extends Dictionary, Mutations extends MutationsDictionary<Mutations>> = {
    [Key in keyof Mutations]: (state: State, payload: ExtractPayload<Mutations[Key]>) => void;
};

// @public
export function namespacedDebounce<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedTimeWireOperator<ModuleName, AnyWire>;

// @public
export function namespacedThrottle<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedTimeWireOperator<ModuleName, AnyWire>;

// @public
export type NamespacedTimeRetrieving<ModuleName extends XModuleName> = (storeModule: StoreModuleStateAndGetters<ModuleName>) => number;

// @public
export type NamespacedTimeWireOperator<ModuleName extends XModuleName, Wire> = (wire: Wire, timeRetrieving: NamespacedTimeRetrieving<ModuleName>, raceEvent?: XEvent | XEvent[]) => Wire;

// @public
export interface NamespacedWireCommit<ModuleName extends XModuleName> {
    // (undocumented)
    <MutationName extends MutationNamesFor<ModuleName>>(mutation: MutationName): Wire<ExtractMutationPayload<ModuleName, MutationName>>;
    // (undocumented)
    <MutationName extends MutationNamesFor<ModuleName>>(mutation: MutationName, payload: NamespacedWireCommitPayload<ModuleName, MutationName>): AnyWire;
}

// @public
export function namespacedWireCommit<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedWireCommit<ModuleName>;

// @public
export type NamespacedWireCommitPayload<ModuleName extends XModuleName, MutationName extends MutationNamesFor<ModuleName>> = ExtractMutationPayload<ModuleName, MutationName> | ((stateAndGetters: StoreModuleStateAndGetters<ModuleName>) => ExtractMutationPayload<ModuleName, MutationName>);

// @public
export type NamespacedWireCommitWithoutPayload<ModuleName extends XModuleName> = <MutationName extends PropsWithType<ExtractMutations<XModulesTree[ModuleName]>, () => any>>(mutation: MutationName) => AnyWire;

// @public
export function namespacedWireCommitWithoutPayload<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedWireCommitWithoutPayload<ModuleName>;

// @public
export interface NamespacedWireDispatch<ModuleName extends XModuleName> {
    // (undocumented)
    <ActionName extends ActionNamesFor<ModuleName>>(action: ActionName): Wire<ExtractActionPayload<ModuleName, ActionName>>;
    // (undocumented)
    <ActionName extends ActionNamesFor<ModuleName>>(action: ActionName, payload: NamespacedWireDispatchPayload<ModuleName, ActionName>): AnyWire;
}

// @public
export function namespacedWireDispatch<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedWireDispatch<ModuleName>;

// @public
export type NamespacedWireDispatchPayload<ModuleName extends XModuleName, ActionName extends ActionNamesFor<ModuleName>> = ExtractActionPayload<ModuleName, ActionName> | ((stateAndGetters: StoreModuleStateAndGetters<ModuleName>) => ExtractActionPayload<ModuleName, ActionName>);

// @public
export type NamespacedWireDispatchWithoutPayload<ModuleName extends XModuleName> = <ActionName extends PropsWithType<ExtractActions<XModulesTree[ModuleName]>, () => any>>(action: ActionName) => AnyWire;

// @public
export function namespacedWireDispatchWithoutPayload<ModuleName extends XModuleName>(moduleName: ModuleName): NamespacedWireDispatchWithoutPayload<ModuleName>;

// @public
export class NextQueries extends Vue_2 {
    protected animation: Vue_2;
    protected maxItemsToRender: number;
    // (undocumented)
    protected get nextQueries(): NextQuery_2[];
    // (undocumented)
    storedNextQueries: NextQuery_2[];
}

// @public
export const nextQueries: NextQueriesXStoreModule['getters']['nextQueries'];

// @public
export type NextQueriesActionContext = XActionContext<NextQueriesState, NextQueriesGetters, NextQueriesMutations, NextQueriesActions>;

// @public
export interface NextQueriesActions {
    cancelFetchAndSaveNextQueries(): void;
    fetchAndSaveNextQueries(): void;
    fetchNextQueries(): NextQuery_2[] | null;
    setQueryFromLastHistoryQuery(historyQueries: HistoryQuery_2[]): void;
}

// @public
export interface NextQueriesConfig {
    hideSessionQueries: boolean;
    loadOnInit: boolean;
    maxItemsToRequest: number;
}

// @internal
export const nextQueriesEmitters: {
    NextQueriesChanged: {
        selector: (_: NextQueriesState, getters: Returns<GettersTree<NextQueriesState, NextQueriesGetters>>) => NextQuery_2[];
        filter: typeof areNextQueriesDifferent;
    };
    NextQueriesRequestChanged: (_: NextQueriesState, getters: Returns<GettersTree<NextQueriesState, NextQueriesGetters>>) => NextQueriesRequest | null;
};

// @public
export interface NextQueriesGetters {
    nextQueries: NextQuery_2[];
    request: NextQueriesRequest | null;
}

// @public
export interface NextQueriesMutations extends StatusMutations {
    setNextQueries(nextQueries: NextQuery_2[]): void;
    setParams(params: Dictionary<unknown>): void;
    setQuery(newQuery: string): void;
    setSearchedQueries(searchedQueries: HistoryQuery_2[]): void;
}

// @public
export const nextQueriesRequest: NextQueriesXStoreModule['getters']['request'];

// @public
export interface NextQueriesState extends StatusState {
    config: NextQueriesConfig;
    nextQueries: NextQuery_2[];
    params: Dictionary<unknown>;
    query: string;
    searchedQueries: HistoryQuery_2[];
}

// @internal
export const nextQueriesWiring: {
    UserAcceptedAQuery: {
        setNextQueriesQuery: Wire<string>;
    };
    SessionHistoryQueriesChanged: {
        setSearchedQueries: Wire<HistoryQuery_2[]>;
        setQueryFromLastHistoryQueryWire: Wire<HistoryQuery_2[]>;
    };
    NextQueriesRequestChanged: {
        fetchAndSaveNextQueriesWire: AnyWire;
    };
    ExtraParamsChanged: {
        setNextQueriesExtraParams: Wire<Dictionary<unknown>>;
    };
};

// @public
export interface NextQueriesXEvents {
    NextQueriesChanged: NextQuery_2[];
    NextQueriesDisplayed: NextQuery_2[];
    NextQueriesRequestChanged: NextQueriesRequest | null;
    UserSelectedANextQuery: NextQuery_2;
}

// @public
export type NextQueriesXModule = XModule<NextQueriesXStoreModule>;

// @public
export const nextQueriesXModule: NextQueriesXModule;

// @public
export type NextQueriesXStoreModule = XStoreModule<NextQueriesState, NextQueriesGetters, NextQueriesMutations, NextQueriesActions>;

// @internal
export const nextQueriesXStoreModule: NextQueriesXStoreModule;

// @public
export class NextQuery extends Vue_2 {
    protected get events(): Partial<XEventsTypes>;
    protected suggestion: NextQuery_2;
}

// @public
export type NiladicFunction = () => any;

// @internal
export const NoElement: ExtendedVue<Vue_2, unknown, unknown, unknown, Record<never, any>>;

// @public
export type NonPrimitive = Array<any> | Record<any, any>;

// @internal
export function noOp(): any;

// @public
export const normalizedQuery: QuerySuggestionsXStoreModule['getters']['normalizedQuery'];

// @public
export function normalizeString(string: string | undefined): string;

// @public
export class NoSuggestions extends Vue_2 {
    // (undocumented)
    beforeDestroy(): void;
    // (undocumented)
    created(): void;
    // @internal
    protected deleteSuggestionsEvents(): void;
    // @internal
    protected get dividedMessage(): string[];
    // @internal
    protected get events(): Partial<XEventsTypes>;
    protected eventsToRender: XEventArrayPayload[];
    // (undocumented)
    protected eventSubscriptions: Subscription[];
    // @internal
    protected get hasSuggestionsOrLoading(): boolean;
    // @internal
    protected makeReactiveAndSubscribeEvents(eventsToRender: XEventArrayPayload[]): void;
    message: string;
    // @internal
    protected onEventsToRenderConfigChanged(newEventsToRender: XEventArrayPayload[]): void;
    // @internal
    protected onQueryChanged(): void;
    // (undocumented)
    query: string;
    // (undocumented)
    protected suggestionsEvents: Partial<Record<XEventArrayPayload, any[] | null>>;
    // @internal
    protected unsubscribeEvents(): void;
}

// @public
export interface NoSuggestionsActions {
}

// @public
export interface NoSuggestionsGetters {
}

// @public
export interface NoSuggestionsMutations {
    setQuery(newQuery: string): void;
}

// @public
export interface NoSuggestionsState {
    query: string;
}

// @internal
export const noSuggestionsWiring: {
    UserIsTypingAQuery: {
        setNoSuggestionsQuery: Wire<string>;
    };
    UserAcceptedAQuery: {
        setNoSuggestionsQuery: Wire<string>;
    };
    UserClearedQuery: {
        clearNoSuggestionsQuery: AnyWire;
    };
};

// @public
export type NoSuggestionsXModule = XModule<NoSuggestionsXStoreModule>;

// @public
export const noSuggestionsXModule: NoSuggestionsXModule;

// @public
export type NoSuggestionsXStoreModule = XStoreModule<NoSuggestionsState, NoSuggestionsGetters, NoSuggestionsMutations, NoSuggestionsActions>;

// @internal
export const noSuggestionsXStoreModule: NoSuggestionsXStoreModule;

// @public (undocumented)
export const Nq1Icon: {};

// @public (undocumented)
export const Nq2Icon: {};

// @public (undocumented)
export const Nq3Icon: {};

// @public (undocumented)
export const Nq4Icon: {};

// @public
export function objectFilter<T extends Dictionary>(obj: T | undefined | null, isIncluded: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => boolean): T;

// @internal
export interface ObserverOptions {
    margin: number;
    root: HTMLElement | null;
    vNode: VNode;
}

// @public
export type Pair<Type> = [Type, Type];

// @public
export class PartialQueryButton extends Vue_2 {
    protected get events(): Partial<XEventsTypes>;
    query: string;
}

// @public
export class PartialResultsList extends Vue_2 {
    protected animation: Vue_2 | string;
    // Warning: (ae-forgotten-export) The symbol "PartialResult" needs to be exported by the entry point index.d.ts
    items: PartialResult[];
    protected maxItemsToRender: number;
    // @internal
    protected get partialResults(): PartialResult[];
}

// @public (undocumented)
export const PlusIcon: {};

// @internal
export interface Point {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @internal
export type Points = [Point, Point];

// @public
export class PopularSearch extends Vue_2 {
    protected get events(): Partial<XEventsTypes>;
    protected suggestion: Suggestion;
}

// @public
export class PopularSearches extends Vue_2 {
    protected animation: Vue_2;
    protected maxItemsToRender: number;
    // (undocumented)
    protected get popularSearches(): Suggestion[];
    // (undocumented)
    storedPopularSearches: Suggestion[];
}

// @public
export const popularSearches: PopularSearchesXStoreModule['getters']['popularSearches'];

// @public
export type PopularSearchesActionContext = XActionContext<PopularSearchesState, PopularSearchesGetters, PopularSearchesMutations, PopularSearchesActions>;

// @public
export interface PopularSearchesActions {
    cancelFetchAndSaveSuggestions(): void;
    fetchAndSaveSuggestions(): void;
    fetchSuggestions(): Suggestion[];
}

// @public
export interface PopularSearchesConfig {
    hideSessionQueries: boolean;
    maxItemsToRequest: number;
    showExtraSuggestionWithoutFilter: boolean;
}

// @internal
export const popularSearchesEmitters: {
    PopularSearchesRequestChanged: {
        selector: (_: PopularSearchesState, getters: Returns<GettersTree<PopularSearchesState, PopularSearchesGetters>>) => SuggestionsRequest;
        immediate: true;
    };
};

// @public
export interface PopularSearchesGetters {
    popularSearches: Suggestion[];
    request: SuggestionsRequest;
}

// @public
export interface PopularSearchesMutations extends StatusMutations {
    setParams(params: Dictionary<unknown>): void;
    setSearchedQueries(searchedQueries: HistoryQuery_2[]): void;
    setSuggestions(suggestions: Suggestion[]): void;
}

// @public
export const popularSearchesRequest: PopularSearchesXStoreModule['getters']['request'];

// @public
export interface PopularSearchesState extends StatusState {
    config: PopularSearchesConfig;
    params: Dictionary<unknown>;
    popularSearches: Suggestion[];
    searchedQueries: HistoryQuery_2[];
}

// @internal
export const popularSearchesWiring: {
    PopularSearchesRequestChanged: {
        retrievePopularSuggestions: AnyWire;
    };
    SessionHistoryQueriesChanged: {
        setSearchedQueriesInPopularSearches: Wire<HistoryQuery_2[]>;
    };
    ExtraParamsChanged: {
        setPopularSearchesExtraParams: Wire<Dictionary<unknown>>;
    };
};

// @public
export interface PopularSearchesXEvents {
    PopularSearchDisplayed: Suggestion[];
    PopularSearchesRequestChanged: SuggestionsRequest;
    UserSelectedAPopularSearch: Suggestion;
}

// @public
export type PopularSearchesXModule = XModule<PopularSearchesXStoreModule>;

// @public
export const popularSearchesXModule: PopularSearchesXModule;

// @public
export type PopularSearchesXStoreModule = XStoreModule<PopularSearchesState, PopularSearchesGetters, PopularSearchesMutations, PopularSearchesActions>;

// @internal
export const popularSearchesXStoreModule: PopularSearchesXStoreModule;

// @public
export type Primitive = string | number | boolean | undefined | null | symbol | AnyFunction;

// @public
export interface PrivateXModuleOptions<Module extends AnyXModule> {
    storeEmitters?: Partial<StoreEmitters<Module['storeModule']>>;
    storeModule?: XStoreModuleOptions<Module['storeModule']>;
}

// @public
export type PrivateXModulesOptions = {
    [ModuleName in XModuleName]?: PrivateXModuleOptions<XModulesTree[ModuleName]>;
};

// @public
export class Promoted extends Vue_2 {
    // Warning: (ae-forgotten-export) The symbol "Promoted" needs to be exported by the entry point index.d.ts
    promoted: Promoted_2;
}

// @public
export class PromotedsList extends SearchItemsInjectionMixin {
    protected animation: Vue_2 | string;
    // @internal
    get items(): SearchItem[];
    stateItems: Promoted_2[];
}

// @public
export type PropsWithType<Type, PropType> = {
    [Key in keyof Type]: Type[Key] extends PropType ? Key : never;
}[keyof Type];

// @public
export type QueryOrigin = 'back_from_search' | 'back_from_pdp' | 'default' | 'discovery_wall' | 'empathize_category' | 'empathize_next_queries' | 'empathize_recommendations' | 'empathize_reference' | 'empathize_term' | 'empathize_trending' | 'empty_search' | 'history' | 'linked' | 'next_query' | 'next_query_grid' | 'no_results' | 'partial' | 'related_tag' | 'spellcheck';

// @public
export class QuerySuggestion extends Vue_3 {
    // @internal
    protected event: Partial<XEventsTypes>;
    // @internal
    query: string;
    protected suggestion: Suggestion;
}

// @public
export class QuerySuggestions extends Vue_2 {
    protected animation: Vue_2;
    // @internal
    suggestions: Suggestion[];
}

// @public
export const querySuggestions: ({ query, suggestions, config }: QuerySuggestionsState) => Suggestion[];

// @public
export type QuerySuggestionsActionContext = XActionContext<QuerySuggestionsState, QuerySuggestionsGetters, QuerySuggestionsMutations, QuerySuggestionsActions>;

// @public
export interface QuerySuggestionsActions {
    cancelFetchAndSaveSuggestions(): void;
    fetchAndSaveSuggestions(): void;
    fetchSuggestions(): Suggestion[];
}

// @public
export interface QuerySuggestionsConfig {
    debounceInMs: number;
    hideIfEqualsQuery: boolean;
    maxItemsToRequest: number;
    showExtraSuggestionWithoutFilter: boolean;
}

// @internal
export const querySuggestionsEmitters: {
    QuerySuggestionsChanged: (state: QuerySuggestionsState) => Suggestion[];
    QuerySuggestionsRequestChanged: (_: QuerySuggestionsState, getters: Returns<GettersTree<QuerySuggestionsState, QuerySuggestionsGetters>>) => SuggestionsRequest | null;
};

// @public
export class QuerySuggestionsGetter implements GettersClass<QuerySuggestionsXStoreModule> {
    // @internal
    protected isInQuerySuggestions(normalizedQuery: string): (suggestion: Suggestion) => boolean;
    querySuggestions({ query, suggestions, config }: QuerySuggestionsState): Suggestion[];
}

// @public
export interface QuerySuggestionsGetters {
    normalizedQuery: string;
    querySuggestions: Suggestion[];
    request: SuggestionsRequest | null;
}

// @public
export interface QuerySuggestionsMutations extends StatusMutations {
    setParams(params: Dictionary<unknown>): void;
    setQuery(newQuery: string): void;
    setSuggestions(suggestions: Suggestion[]): void;
}

// @public
export const querySuggestionsRequest: QuerySuggestionsXStoreModule['getters']['request'];

// @public
export interface QuerySuggestionsState extends StatusState {
    config: QuerySuggestionsConfig;
    params: Dictionary<unknown>;
    query: string;
    suggestions: Suggestion[];
}

// @internal
export const querySuggestionsWiring: {
    UserIsTypingAQuery: {
        setQuerySuggestionsQueryDebounce: AnyWire;
    };
    UserAcceptedAQuery: {
        setQuerySuggestionsQuery: Wire<string>;
    };
    UserClearedQuery: {
        clearQuerySuggestionsQuery: AnyWire;
        cancelFetchAndSaveSuggestionsWire: AnyWire;
    };
    QuerySuggestionsRequestChanged: {
        fetchAndSaveSuggestionsWire: AnyWire;
    };
    ExtraParamsChanged: {
        setQuerySuggestionsExtraParams: Wire<Dictionary<unknown>>;
    };
};

// @public
export interface QuerySuggestionsXEvents {
    QuerySuggestionsChanged: Suggestion[];
    QuerySuggestionsDisplayed: Suggestion[];
    QuerySuggestionsRequestChanged: SuggestionsRequest | null;
    UserSelectedAQuerySuggestion: Suggestion;
}

// @public
export type QuerySuggestionsXModule = XModule<QuerySuggestionsXStoreModule>;

// @public
export const querySuggestionsXModule: QuerySuggestionsXModule;

// @public
export type QuerySuggestionsXStoreModule = XStoreModule<QuerySuggestionsState, QuerySuggestionsGetters, QuerySuggestionsMutations, QuerySuggestionsActions>;

// @internal
export const querySuggestionsXStoreModule: QuerySuggestionsXStoreModule;

// @public
export class Recommendations extends Vue_2 {
    protected animation: Vue_2;
    recommendations: Result[];
    protected resultClickExtraEvents: PropsWithType<XEventsTypes, Result>[];
}

// @public
export const RECOMMENDATIONS_ORIGIN = "default";

// @public
export type RecommendationsActionContext = XActionContext<RecommendationsState, RecommendationsGetters, RecommendationsMutations, RecommendationsActions>;

// @public
export interface RecommendationsActions {
    cancelFetchAndSaveRecommendations(): void;
    fetchAndSaveRecommendations(): void;
    fetchRecommendations(): Result[];
}

// @public
export interface RecommendationsConfig {
    maxItemsToRequest: number;
}

// @internal
export const recommendationsEmitters: {
    RecommendationsRequestChanged: {
        selector: (_: RecommendationsState, getters: Returns<GettersTree<RecommendationsState, RecommendationsGetters>>) => TopRecommendationsRequest;
        immediate: true;
    };
};

// @public
export interface RecommendationsGetters {
    request: TopRecommendationsRequest;
}

// @public
export interface RecommendationsMutations extends StatusMutations {
    setParams(params: Dictionary<unknown>): void;
    setRecommendations(recommendations: Result[]): void;
}

// @public
export const recommendationsRequest: RecommendationsXStoreModule['getters']['request'];

// @public
export interface RecommendationsState extends StatusState {
    config: RecommendationsConfig;
    origin: string;
    params: Dictionary<unknown>;
    recommendations: Result[];
}

// @internal
export const recommendationsWiring: {
    RecommendationsRequestChanged: {
        fetchAndSaveRecommendations: AnyWire;
    };
    UserClickedColumnPicker: {};
    ExtraParamsChanged: {
        setRecommendationsExtraParams: Wire<unknown>;
    };
};

// @public
export interface RecommendationsXEvents {
    RecommendationsChanged: Result[];
    RecommendationsRequestChanged: TopRecommendationsRequest;
    UserClickedARecommendation: Result;
}

// @public
export type RecommendationsXModule = XModule<RecommendationsXStoreModule>;

// @public
export const recommendationsXModule: RecommendationsXModule;

// @public
export type RecommendationsXStoreModule = XStoreModule<RecommendationsState, RecommendationsGetters, RecommendationsMutations, RecommendationsActions>;

// @internal
export const recommendationsXStoreModule: RecommendationsXStoreModule;

// @public
export function reduce<T extends Dictionary, V>(obj: T | undefined | null, reducer: (accumulator: V, key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => V, initialValue: V): V;

// @public
export const refreshHistoryQueriesSession: AnyWire;

// @public
export const refreshSession: HistoryQueriesXStoreModule['actions']['refreshSession'];

// @public
export class RelatedTag extends Vue_2 {
    // @internal
    protected get dynamicClasses(): VueCSSClasses;
    // @internal
    protected get events(): Partial<RelatedTagsXEvents>;
    // @internal
    protected get isSelected(): boolean;
    // Warning: (ae-forgotten-export) The symbol "RelatedTag" needs to be exported by the entry point index.d.ts
    protected relatedTag: RelatedTag_2;
    // @internal
    selectedRelatedTags: RelatedTag_2[];
}

// @public
export class RelatedTags extends Vue_2 {
    protected animation: Vue_2;
    protected maxItemsToRender?: number;
    // (undocumented)
    protected get relatedTags(): RelatedTag_2[];
    // (undocumented)
    storedRelatedTags: RelatedTag_2[];
}

// @public
export const relatedTags: RelatedTagsXStoreModule['getters']['relatedTags'];

// @public
export type RelatedTagsActionContext = XActionContext<RelatedTagsState, RelatedTagsGetters, RelatedTagsMutations, RelatedTagsActions>;

// @public
export interface RelatedTagsActions {
    cancelFetchAndSaveRelatedTags(): void;
    fetchAndSaveRelatedTags(): void;
    fetchRelatedTags(): RelatedTag_2[];
    toggleRelatedTag(relatedTag: RelatedTag_2): void;
}

// @public
export interface RelatedTagsConfig {
    maxItemsToRequest: number;
}

// @internal
export const relatedTagsEmitters: {
    RelatedTagsChanged: (state: RelatedTagsState) => RelatedTag_2[];
    RelatedTagsRequestChanged: (_: RelatedTagsState, getters: Returns<GettersTree<RelatedTagsState, RelatedTagsGetters>>) => RelatedTagsRequest | null;
    SelectedRelatedTagsChanged: (state: RelatedTagsState) => RelatedTag_2[];
};

// @public
export interface RelatedTagsGetters {
    relatedTags: RelatedTag_2[];
    request: RelatedTagsRequest | null;
}

// @public
export interface RelatedTagsMutations extends StatusMutations {
    setParams(params: Dictionary<unknown>): void;
    setQuery(newQuery: string): void;
    setRelatedTags(relatedTags: RelatedTag_2[]): void;
    setSelectedRelatedTags(selectedRelatedTags: RelatedTag_2[]): void;
}

// @public
export const relatedTagsRequest: RelatedTagsXStoreModule['getters']['request'];

// @public
export interface RelatedTagsState extends StatusState {
    config: RelatedTagsConfig;
    params: Dictionary<unknown>;
    query: string;
    relatedTags: RelatedTag_2[];
    selectedRelatedTags: RelatedTag_2[];
}

// @internal
export const relatedTagsWiring: {
    UserAcceptedAQuery: {
        setRelatedTagsQuery: Wire<string>;
        clearSelectedRelatedTags: AnyWire;
    };
    UserPickedARelatedTag: {
        toggleRelatedTagWire: Wire<RelatedTag_2>;
    };
    RelatedTagsRequestChanged: {
        fetchAndSaveRelatedTagsWire: AnyWire;
    };
    UserClearedQuery: {
        cancelFetchAndSaveRelatedTagsWire: AnyWire;
        clearRelatedTagsQuery: AnyWire;
        clearSelectedRelatedTags: AnyWire;
    };
    ExtraParamsChanged: {
        setRelatedTagsExtraParams: Wire<Dictionary<unknown>>;
    };
};

// @public
export interface RelatedTagsXEvents {
    RelatedTagsChanged: RelatedTag_2[];
    RelatedTagsRequestChanged: RelatedTagsRequest | null;
    SelectedRelatedTagsChanged: RelatedTag_2[];
    UserDeselectedARelatedTag: RelatedTag_2;
    UserPickedARelatedTag: RelatedTag_2;
    UserSelectedARelatedTag: RelatedTag_2;
}

// @public
export type RelatedTagsXModule = XModule<RelatedTagsXStoreModule>;

// @public
export const relatedTagsXModule: RelatedTagsXModule;

// @public
export type RelatedTagsXStoreModule = XStoreModule<RelatedTagsState, RelatedTagsGetters, RelatedTagsMutations, RelatedTagsActions>;

// @internal
export const relatedTagsXStoreModule: RelatedTagsXStoreModule;

// @public
export const removeFromHistory: HistoryQueriesXStoreModule['actions']['removeFromHistory'];

// @public
export class RemoveHistoryQuery extends Vue_2 {
    protected historyQuery: HistoryQuery_2;
    protected get removeHistoryQueryEvent(): Partial<XEventsTypes>;
}

// @public
export const removeHistoryQuery: Wire<HistoryQuery_2>;

// @public
export class RenderlessExtraParams extends Vue_2 {
    // @internal
    created(): void;
    defaultValue?: unknown;
    // @internal
    protected emitEvent(event: keyof ExtraParamsXEvents, value: unknown): void;
    extraParams: Dictionary<unknown>;
    name: string;
    // @internal
    protected updateValue(newValue: unknown): void;
    // @internal
    protected get value(): unknown;
}

// @public
export const resetFacets: AnyWire;

// @public
export const resetPage: AnyWire;

// @public
export const resetSort: AnyWire;

// @public
export const resetSpellcheckQuery: AnyWire;

// @public
export class ResultsList extends Vue_2 implements InfiniteScroll {
    protected animation: Vue_2 | string;
    items: Result[];
    // @internal
    onInfiniteScrollEnd(): void;
}

// @public
export type Returns<T extends Dictionary<AnyFunction>> = {
    [K in keyof T]: ReturnType<T[K]>;
};

// @public
export type RootStoreStateAndGetters = Pick<Store<RootXStoreState>, 'state' | 'getters'>;

// @internal
export const RootXStoreModule: Module<XModuleState, any>;

// @public
export interface RootXStoreState {
    // (undocumented)
    x: {
        [Module in XModuleName]: ExtractState<Module>;
    };
}

// @public
export const sanitize: (str: string) => string;

// @public
export const saveQuery: IdentifierResultsXStoreModule['actions']['saveQuery'];

// @public
export type ScrollDirection = 'UP' | 'DOWN';

// @public
export class ScrollMixin extends Vue_2 {
    // @internal
    protected clientHeight: number;
    // @internal
    protected currentPosition: number;
    // @internal
    protected direction: ScrollDirection;
    distanceToBottom: number;
    // @internal
    protected get distanceToEnd(): number;
    // @internal
    emitScroll(_newScrollPosition: number, oldScrollPosition: number): void;
    // @internal
    emitScrollAlmostAtEnd(isScrollAlmostAtEnd: boolean): void;
    // @internal
    emitScrollAtEnd(isScrollAtEnd: boolean): void;
    // @internal
    emitScrollDirection(direction: ScrollDirection): void;
    // @internal
    emitScrollReachedAtStart(isScrollAtStart: boolean): void;
    // @internal
    protected get hasScrollAlmostReachedEnd(): boolean;
    // @internal
    protected get hasScrollReachedEnd(): boolean;
    // @internal
    protected get hasScrollReachedStart(): boolean;
    // @internal
    protected previousPosition: number;
    // @internal
    protected get scrollDirection(): ScrollDirection;
    // @internal
    protected get scrollEndPosition(): number;
    // @internal
    protected scrollHeight: number;
    throttleMs: number;
}

// @public
export type SearchActionContext = XActionContext<SearchState, SearchGetters, SearchMutations, SearchActions>;

// @public
export interface SearchActions {
    cancelFetchAndSaveSearchResponse(): void;
    fetchAndSaveSearchResponse(): void;
    // Warning: (ae-forgotten-export) The symbol "SearchResponse" needs to be exported by the entry point index.d.ts
    fetchSearchResponse(): SearchResponse;
    increasePageAppendingResults(): void;
}

// @public
export interface SearchBoxActions {
}

// @internal
export const searchBoxEmitters: {
    SearchBoxQueryChanged: (_: SearchBoxState, getters: Returns<GettersTree<SearchBoxState, SearchBoxGetters>>) => string;
    UserClearedQuery: {
        selector: (state: SearchBoxState) => string;
        filter: typeof isStringEmpty;
    };
};

// @public
export interface SearchBoxGetters {
    trimmedQuery: string;
}

// @public
export interface SearchBoxMutations {
    setQuery(newQuery: string): void;
}

// @public
export interface SearchBoxState {
    query: string;
}

// @internal
export const searchBoxWiring: {
    UserIsTypingAQuery: {
        setSearchBoxQuery: Wire<string>;
    };
    UserAcceptedAQuery: {
        setSearchBoxQuery: Wire<string>;
    };
    UserPressedClearSearchBoxButton: {
        clearSearchBoxQuery: AnyWire;
    };
};

// @public
export interface SearchBoxXEvents {
    SearchBoxQueryChanged: string;
    UserBlurredSearchBox: void;
    UserClearedQuery: string;
    UserClickedSearchBox: void;
    UserFocusedSearchBox: void;
    UserIsTypingAQuery: string;
    UserPressedClearSearchBoxButton: void;
    UserPressedEnterKey: string;
    UserPressedSearchButton: string;
    UserTalked: string;
}

// @public
export type SearchBoxXModule = XModule<SearchBoxXStoreModule>;

// @public
export const searchBoxXModule: SearchBoxXModule;

// @public
export type SearchBoxXStoreModule = XStoreModule<SearchBoxState, SearchBoxGetters, SearchBoxMutations, SearchBoxActions>;

// @internal
export const searchBoxXStoreModule: SearchBoxXStoreModule;

// @public
export class SearchButton extends Vue_2 {
    // (undocumented)
    protected get dynamicClasses(): VueCSSClasses;
    // (undocumented)
    protected get events(): Partial<XEventsTypes>;
    // (undocumented)
    protected get isQueryEmpty(): boolean;
    // (undocumented)
    query: string;
}

// @public
export interface SearchConfig {
    pageSize: number;
}

// @internal
export const searchEmitters: {
    ResultsChanged: (state: SearchState) => Result[];
    SearchRequestChanged: (_: SearchState, getters: Returns<GettersTree<SearchState, SearchGetters>>) => SearchRequest | null;
    FacetsChanged: (state: SearchState) => Facet[];
    SpellcheckChanged: (state: SearchState) => string;
};

// @public
export interface SearchGetters {
    request: SearchRequest | null;
}

// @public (undocumented)
export const SearchIcon: {};

// @public
export class SearchInput extends Vue_2 {
    // (undocumented)
    $refs: {
        input: HTMLInputElement;
    };
    protected autocompleteKeyboardKeys: string[];
    protected autocompleteSuggestionsEvent: PropsWithType<XEventsTypes, Suggestion[]>;
    protected autofocus: boolean;
    // @internal
    cancelDebouncedUserAcceptedAQuery(): void;
    // (undocumented)
    protected debouncedUserAcceptedAQuery: DebouncedFunction<[string]>;
    // @internal
    emitDebouncedUserAcceptedAQuery(query: string): void;
    // @internal
    protected emitUserAcceptedAQuery(query: string): void;
    // @internal
    protected emitUserBlurredSearchBox(): void;
    // @internal
    protected emitUserClickedSearchBox(): void;
    // @internal
    protected emitUserFocusedSearchBox(): void;
    // @internal
    protected emitUserIsTypingAQueryEvents(): void;
    // @internal
    protected emitUserPressedArrowKey(event: KeyboardEvent): void;
    // @internal
    protected emitUserPressedEnterKey(): void;
    // @internal
    protected eventMetadata(): Omit<WireMetadata, 'moduleName'>;
    // @internal
    focusInput(): void;
    protected instant: boolean;
    protected instantDebounceInMs: number;
    protected maxLength: number;
    // (undocumented)
    mounted(): void;
    // (undocumented)
    query: string;
}

// Warning: (ae-forgotten-export) The symbol "Identifiable" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NamedModel" needs to be exported by the entry point index.d.ts
//
// @public
export type SearchItem = Identifiable & NamedModel;

// @public
export class SearchItemsList extends Vue_2 {
    protected animation: Vue_2 | string;
    // @internal
    protected get computedSearchItems(): {
        dataTest: string;
        class: string[];
    }[];
    protected searchItems: SearchItem[];
}

// @public
export interface SearchMutations extends StatusMutations {
    appendResults(results: Result[]): void;
    setBanners(banners: Banner_2[]): void;
    setFacets(facets: Facet[]): void;
    setIsAppendResults(isAppendResults: boolean): void;
    setPage(page: number): void;
    setPageSize(pageSize: number): void;
    setParams(params: Dictionary<unknown>): void;
    setPartialResults(partialResults: PartialResult[]): void;
    setPromoteds(promoteds: Promoted_2[]): void;
    setQuery(newQuery: string): void;
    setRelatedTags(relatedTags: RelatedTag_2[]): void;
    setResults(results: Result[]): void;
    setSelectedFilters(selectedFilters: Filter[]): void;
    // Warning: (ae-forgotten-export) The symbol "Sort" needs to be exported by the entry point index.d.ts
    setSort(sort: Sort): void;
    setSpellcheck(spellcheckedQuery: string): void;
    setTotalResults(totalResults: number): void;
}

// @public
export const searchRequest: SearchXStoreModule['getters']['request'];

// @public
export interface SearchState extends StatusState {
    banners: Banner_2[];
    config: SearchConfig;
    facets: Facet[];
    isAppendResults: boolean;
    page: number;
    params: Dictionary<unknown>;
    partialResults: PartialResult[];
    promoteds: Promoted_2[];
    query: string;
    relatedTags: RelatedTag_2[];
    results: Result[];
    selectedFilters: Dictionary<Filter[]>;
    sort: Sort;
    spellcheckedQuery: string;
    totalResults: number;
}

// @public (undocumented)
export const SearchTinyIcon: {};

// @internal
export const searchWiring: {
    UserAcceptedAQuery: {
        resetPage: AnyWire;
        setSearchQuery: Wire<string>;
        resetSort: AnyWire;
    };
    UserAcceptedSpellcheckQuery: {
        resetPage: AnyWire;
        resetSpellcheckQuery: AnyWire;
    };
    UserClearedQuery: {
        resetPage: AnyWire;
        setSearchQuery: Wire<string>;
        cancelFetchAndSaveSearchResponseWire: AnyWire;
    };
    SearchRequestChanged: {
        fetchAndSaveSearchResponseWire: AnyWire;
    };
    SelectedRelatedTagsChanged: {
        resetPage: AnyWire;
        setRelatedTags: Wire<RelatedTag_2[]>;
    };
    SelectedFiltersChanged: {
        resetPage: AnyWire;
        setSelectedFilters: Wire<Filter[]>;
    };
    UserClickedASort: {
        resetPage: AnyWire;
        setSort: Wire<string>;
    };
    SelectedSortProvided: {
        resetPage: AnyWire;
        setSort: Wire<string>;
    };
    UserReachedResultsListEnd: {
        increasePageAppendingResults: AnyWire;
    };
    ExtraParamsChanged: {
        setSearchExtraParams: Wire<Dictionary<unknown>>;
        resetPage: AnyWire;
        resetSort: AnyWire;
        resetFacets: AnyWire;
    };
};

// @public
export interface SearchXEvents {
    FacetsChanged: Facet[];
    ResultsChanged: Result[];
    SearchRequestChanged: SearchRequest | null;
    SelectedSortProvided: Sort;
    SpellcheckChanged: string;
    UserClickedASort: Sort;
    UserClickedPartialQuery: string;
    UserReachedResultsListEnd: void;
}

// @public
export type SearchXModule = XModule<SearchXStoreModule>;

// @public
export const searchXModule: SearchXModule;

// @public
export type SearchXStoreModule = XStoreModule<SearchState, SearchGetters, SearchMutations, SearchActions>;

// @internal
export const searchXStoreModule: SearchXStoreModule;

// @public
export const sessionHistoryQueries: HistoryQueriesXStoreModule['getters']['sessionHistoryQueries'];

// @public
export const setExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setHistoryQueries: HistoryQueriesXStoreModule['actions']['setHistoryQueries'];

// @public
export const setHistoryQueriesQuery: Wire<string>;

// @public
export const setIdentifierResultsQuery: Wire<string>;

// @public
export const setName: Wire<string | null>;

// @public
export const setNextQueriesExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setNextQueriesQuery: Wire<string>;

// @public
export const setNoSuggestionsQuery: Wire<string>;

// @public
export const setPage: Wire<number>;

// @public
export const setPageSize: Wire<number>;

// @public
export const setPopularSearchesExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setQueryFromLastHistoryQuery: NextQueriesXStoreModule['actions']['setQueryFromLastHistoryQuery'];

// @public
export const setQueryFromLastHistoryQueryWire: Wire<HistoryQuery_2[]>;

// @public
export const setQuerySuggestionsExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setQuerySuggestionsQuery: Wire<string>;

// @public
export const setRecommendationsExtraParams: Wire<unknown>;

// @public
export const setRelatedTags: Wire<RelatedTag_2[]>;

// @public
export const setRelatedTagsExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setRelatedTagsQuery: Wire<string>;

// @public
export const setSearchedQueries: Wire<HistoryQuery_2[]>;

// @public
export const setSearchedQueriesInPopularSearches: Wire<HistoryQuery_2[]>;

// @public
export const setSearchExtraParams: Wire<Dictionary<unknown>>;

// @public
export const setSearchQuery: Wire<string>;

// @public
export const setSelectedFilters: Wire<Filter[]>;

// @public
export const setSort: Wire<string>;

// @internal
export function setXComponentXModuleName(component: Vue_2, name: XModuleName): void;

// @public (undocumented)
export const ShowIcon: {};

// @public
export type SimpleStateSelector<ReturnType, State extends Dictionary, Getters extends Dictionary> = (state: State, getters: Getters) => ReturnType;

// @public
export class SlidingPanel extends Vue_2 {
    $refs: {
        scrollContainer: HTMLElement;
    };
    // (undocumented)
    beforeDestroy(): void;
    // @internal
    protected get cssClasses(): VueCSSClasses;
    // @internal
    debouncedUpdateScrollPosition(): void;
    protected isScrollAtEnd: boolean;
    protected isScrollAtStart: boolean;
    // (undocumented)
    mounted(): void;
    // @internal
    restoreAndUpdateScroll(): void;
    protected scrollFactor: number;
    // @internal
    protected scrollLeft(): void;
    protected scrollObserver: MutationObserver;
    // @internal
    protected scrollRight(): void;
    // @internal
    protected scrollTo(scrollValue: number): void;
    protected showButtons: boolean;
    // @internal
    protected updateScrollPosition(): void;
}

// @public
export interface SnippetConfig {
    [extra: string]: any;
    consent?: boolean;
    currency?: string;
    documentDirection?: DocumentDirection;
    env?: 'live' | 'staging';
    instance: string;
    lang: string;
    scope: string;
    searchLang?: string;
}

// @public
export class SnippetConfigExtraParams extends Vue_2 {
    // @internal
    protected extraParams: Dictionary<unknown>;
    // @internal
    snippetConfig: SnippetConfig;
    // @internal
    syncExtraParams({ instance, env, scope, lang, searchLang, consent, documentDirection, currency, ...snippetExtraParams }: SnippetConfig): void;
}

// Warning: (ae-forgotten-export) The symbol "SortDropdown_base" needs to be exported by the entry point index.d.ts
//
// @public
export class SortDropdown extends SortDropdown_base {
    animation?: string | typeof Vue_2;
    // @internal
    protected emitUserClickedASort(sort: Sort): void;
}

// Warning: (ae-forgotten-export) The symbol "SortList_base" needs to be exported by the entry point index.d.ts
//
// @public
export class SortList extends SortList_base {
    animation?: string | typeof Vue_2;
    // Warning: (ae-forgotten-export) The symbol "SortListItem" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected get listItems(): SortListItem[];
}

// @public
export class SortMixin extends Vue_2 {
    items: Sort[];
    get providedSelectedSort(): Sort;
    // @internal
    selectedSort: Sort;
    value?: Sort;
}

// @public
export interface SpatialNavigation {
    navigateTo(direction: ArrowKey): HTMLElement;
}

// @public
export class Spellcheck extends Vue_2 {
    query: string;
    spellcheckedQuery: string;
}

// @public
export class SpellcheckButton extends Vue_2 {
    protected get events(): Partial<XEventsTypes>;
    spellcheckedQuery: string;
}

// @public
export class StaggeredFadeAndSlide extends Vue_2 {
}

// @public
export class StaggeringTransitionGroup extends Vue_2 {
    // @internal
    protected addClearStaggeringCall(transitionHook?: TransitionHook): TransitionHook;
    // Warning: (ae-forgotten-export) The symbol "TransitionHook" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected addRestorePositionHook(transitionHook?: TransitionHook): TransitionHook;
    // @internal
    protected addTransitionData(vNode: TransitionVNode): void;
    // @internal
    protected applyStagger(vNode: TransitionVNode): void;
    // @internal
    protected applyTranslation(vNode: TransitionVNode): boolean;
    // (undocumented)
    beforeCreate(): void;
    // (undocumented)
    beforeUpdate(): void;
    // @internal
    protected createRelativeBounds(vNode: TransitionVNode): Bounds;
    // @internal
    protected disableClickingEvents(vNode: TransitionVNode): void;
    // @internal
    protected getNextTransitionDelay(): string;
    // Warning: (ae-forgotten-export) The symbol "TransitionTypeNodes" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected getNodesByTransitionType(): TransitionTypeNodes;
    // @internal
    protected isTransitionValidVNode(vNode: VNode): vNode is TransitionVNode;
    // (undocumented)
    mounted(): void;
    // @internal
    moveClass: string;
    // @internal
    protected get moveClassName(): string;
    // @internal
    name: string;
    // @internal
    protected newChildren: TransitionVNode[];
    // @internal
    protected newPositions: WeakMap<Element, Bounds>;
    // Warning: (ae-forgotten-export) The symbol "TransitionVNode" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected oldChildren: TransitionVNode[];
    // Warning: (ae-forgotten-export) The symbol "Bounds" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected oldPositions: WeakMap<Element, Bounds>;
    // @internal
    protected pendingCleanupMoveCallbacks: WeakMap<Element, () => void>;
    // @internal
    protected recordNewPosition(vNode: TransitionVNode): void;
    // @internal
    protected recordOldPosition(vNode: TransitionVNode): void;
    // (undocumented)
    render(createElement: CreateElement): VNode;
    // @internal
    protected staggerCounter: number;
    // @internal
    staggering: number;
    // @internal
    protected startMoveAnimation(moveStagger: string[]): (vNode: TransitionVNode, index: number) => void;
    // @internal
    protected syncOldNodes(vNode: TransitionVNode): void;
    // @internal
    tag: string;
    // Warning: (ae-forgotten-export) The symbol "TransitionData" needs to be exported by the entry point index.d.ts
    //
    // @internal
    protected get transitionData(): TransitionData;
    // (undocumented)
    updated(): void;
    // @internal
    protected wrapperBounds: DOMRect;
}

// @public (undocumented)
export const StarIcon: {};

// @public
export function State<Module extends XModuleName, Path extends keyof ExtractState<Module>>(module: Module, path: Path): DecoratorFor<ExtractState<Module>[Path]>;

// @public
export interface StateSelector<ReturnType, State extends Dictionary, Getters extends Dictionary> extends WatchOptions {
    filter?(newValue: ReturnType, oldValue: ReturnType): boolean;
    // (undocumented)
    selector: SimpleStateSelector<ReturnType, State, Getters>;
}

// @public
export const storageKey: HistoryQueriesXStoreModule['getters']['storageKey'];

// @public
export type StoreEmitters<StoreModule extends AnyXStoreModule> = {
    [Event in XEvent]?: SimpleStateSelector<XEventPayload<Event>, ReturnType<StoreModule['state']>, Returns<StoreModule['getters']>> | StateSelector<XEventPayload<Event>, ReturnType<StoreModule['state']>, Returns<StoreModule['getters']>>;
};

// @public
export type StoreModuleStateAndGetters<ModuleName extends XModuleName> = {
    state: ExtractState<ModuleName>;
    getters: ExtractGetters<ModuleName>;
};

// @public
export interface TaggingActions {
}

// @public
export interface TaggingConfig {
}

// @internal
export const taggingEmitters: {};

// @public
export interface TaggingGetters {
}

// @public
export interface TaggingMutations {
}

// @public
export interface TaggingState {
}

// @internal
export const taggingWiring: {};

// @public
export interface TaggingXEvents {
}

// @public
export type TaggingXModule = XModule<TaggingXStoreModule>;

// @public
export const taggingXModule: TaggingXModule;

// @public
export type TaggingXStoreModule = XStoreModule<TaggingState, TaggingGetters, TaggingMutations, TaggingActions>;

// @internal
export const taggingXStoreModule: TaggingXStoreModule;

// @public
export type TakeNavigationControl = {
    xEvent: PropsWithType<XEventsTypes, ArrowKey>;
    moduleName: XModuleName;
    direction: ArrowKey;
};

// @public
export function throttle<Payload>(wire: Wire<Payload>, timeInMs: TimeRetrieving | number, raceEvent?: XEvent | XEvent[]): Wire<Payload>;

// @public
export interface ThrottleFunction<Params extends any[]> {
    // (undocumented)
    (...args: Params): void;
}

// @public
export const throttleFunction: <Params extends any[]>(fn: (...args: Params) => void, throttleTimeMs: number) => ThrottleFunction<Params>;

// @public
export type TimeRetrieving = (storeModule: Store<RootXStoreState>) => number;

// @public
export const toggleRelatedTag: RelatedTagsXStoreModule['actions']['toggleRelatedTag'];

// @public
export const toggleRelatedTagWire: Wire<RelatedTag_2>;

// @public
export function toKebabCase(str: string): string;

// @public (undocumented)
export const TrashIcon: {};

// @public (undocumented)
export const TrashOpenIcon: {};

// @public (undocumented)
export const TrendingIcon: {};

// @public (undocumented)
export const TrendingTinyIcon: {};

// @public
export interface UrlActions {
}

// @public
export interface UrlConfig {
}

// @internal
export const urlEmitters: {};

// @public
export interface UrlGetters {
}

// @public
export interface UrlMutations {
}

// @public
export interface UrlState {
}

// @internal
export const urlWiring: {};

// @public
export interface UrlXEvents {
}

// @public
export type UrlXModule = XModule<UrlXStoreModule>;

// @public
export const urlXModule: UrlXModule;

// @public
export type UrlXStoreModule = XStoreModule<UrlState, UrlGetters, UrlMutations, UrlActions>;

// @internal
export const urlXStoreModule: UrlXStoreModule;

// @public (undocumented)
export const UserIcon: {};

// @public
export type VueConstructorPartialArgument = Partial<ConstructorParameters<VueConstructor>[0]>;

// @public
export type VueCSSClasses = string | Dictionary<boolean> | (string | Dictionary<boolean>)[];

// @public
export type Wire<PayloadType> = (observable: Observable<WirePayload<PayloadType>>, store: Store<RootXStoreState>, on: XBus['on']) => Subscription;

// @public
export function wireCommit(mutation: string, payloadFactory: (params: RootStoreStateAndGetters) => any): AnyWire;

// @public
export function wireCommit(mutation: string, staticPayload: any): AnyWire;

// @public
export function wireCommit<Payload>(mutation: string): Wire<Payload>;

// @public
export function wireCommitWithoutPayload(mutation: string): AnyWire;

// @public
export function wireDispatch(action: string, payloadFactory: (params: RootStoreStateAndGetters) => any): AnyWire;

// @public
export function wireDispatch(action: string, staticPayload: any): AnyWire;

// @public
export function wireDispatch<Payload>(action: string): Wire<Payload>;

// @public
export function wireDispatchWithoutPayload(action: string): AnyWire;

// @public
export type WireForEvent<Event extends XEvent> = Wire<XEventPayload<Event>>;

// @public
export interface WireMetadata {
    id?: string;
    moduleName: XModuleName | null;
    origin?: QueryOrigin;
    target?: HTMLElement;
}

// @public
export interface WireParams<Payload> extends WirePayload<Payload> {
    // (undocumented)
    store: Store<RootXStoreState>;
}

// @public
export interface WirePayload<PayloadType> {
    eventPayload: PayloadType;
    metadata: WireMetadata;
}

// @public
export interface WireService<SomeService> {
    <SomeMethod extends PropsWithType<SomeService, MonadicFunction>>(method: SomeMethod): Wire<FirstParameter<SomeService[SomeMethod]>>;
    <SomeMethod extends PropsWithType<SomeService, MonadicFunction>>(method: SomeMethod, payload: FirstParameter<SomeService[SomeMethod]>): AnyWire;
}

// @public
export function wireService<SomeService>(service: SomeService): WireService<SomeService>;

// @public
export interface WireServiceWithoutPayload<SomeService> {
    <SomeMethod extends PropsWithType<SomeService, NiladicFunction>>(method: SomeMethod): AnyWire;
}

// @public
export function wireServiceWithoutPayload<SomeService>(service: SomeService): WireServiceWithoutPayload<SomeService>;

// @public
export type Wiring = {
    [E in XEvent]: Dictionary<WireForEvent<E>>;
};

// @public
export interface XActionContext<State extends Dictionary, Getters extends Dictionary, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> extends ActionContext<State, RootXStoreState> {
    // (undocumented)
    commit<MutationName extends PropsWithType<Mutations, () => void>>(mutation: MutationName): void;
    // (undocumented)
    commit<MutationName extends keyof Mutations>(mutation: MutationName, payload: ExtractPayload<Mutations[MutationName]>): void;
    // (undocumented)
    dispatch<ActionName extends PropsWithType<Actions, () => any>>(action: ActionName): ExtractActionReturn<Actions[ActionName]>;
    // (undocumented)
    dispatch<ActionName extends keyof Actions>(action: ActionName, payload: ExtractPayload<Actions[ActionName]>): ExtractActionReturn<Actions[ActionName]>;
    // (undocumented)
    getters: Getters;
}

// @public
export interface XAPI {
    init(config: SnippetConfig): void;
    search(query?: string): void;
    // @internal
    setBus(bus: XBus): void;
    // @internal
    setInitCallback(initCallback: (config: SnippetConfig) => void): void;
}

// @public
export interface XBus {
    emit(event: PropsWithType<XEventsTypes, void>): void;
    emit<Event extends XEvent>(event: Event, payload: XEventPayload<Event>, metadata?: WireMetadata): void;
    on<Event extends XEvent>(event: Event, withMetadata: true): Observable<WirePayload<XEventPayload<Event>>>;
    on<Event extends XEvent>(event: Event, withMetadata?: false): Observable<XEventPayload<Event>>;
    on<Event extends XEvent>(event: Event, withMetadata: boolean): Observable<XEventPayload<Event> | WirePayload<XEventPayload<Event>>>;
}

// @public
export interface XComponent extends Vue_2 {
    // @internal
    [XComponentModule]: XModuleName;
}

// @public
export interface XComponentAliasAPI {
    readonly device: string | null;
    readonly facets: Record<Facet['id'], Facet>;
    readonly historyQueries: ReadonlyArray<HistoryQuery_2>;
    readonly identifierResults: ReadonlyArray<Result>;
    readonly isEmpathizeOpen: boolean;
    readonly nextQueries: ReadonlyArray<NextQuery_2>;
    readonly popularSearches: ReadonlyArray<Suggestion>;
    readonly query: XComponentAliasQueryAPI;
    readonly querySuggestions: ReadonlyArray<Suggestion>;
    readonly recommendations: ReadonlyArray<Result>;
    readonly relatedTags: ReadonlyArray<RelatedTag_2>;
    readonly selectedFilters: Filter[];
    readonly selectedRelatedTags: ReadonlyArray<RelatedTag_2>;
    readonly status: XComponentAliasStatusAPI;
    readonly totalResults: number;
}

// @public
export interface XComponentAliasQueryAPI {
    readonly facets: string;
    readonly nextQueries: string;
    readonly querySuggestions: string;
    readonly relatedTags: string;
    readonly search: string;
    readonly searchBox: string;
}

// @public
export interface XComponentAliasStatusAPI {
    // Warning: (ae-forgotten-export) The symbol "RequestStatus" needs to be exported by the entry point index.d.ts
    readonly identifierResults: RequestStatus | undefined;
    readonly nextQueries: RequestStatus | undefined;
    readonly popularSearches: RequestStatus | undefined;
    readonly querySuggestions: RequestStatus | undefined;
    readonly recommendations: RequestStatus | undefined;
    readonly relatedTags: RequestStatus | undefined;
    readonly search: RequestStatus | undefined;
}

// @public
export interface XComponentAPI extends XComponentBusAPI, XComponentAliasAPI {
}

// @public
export interface XComponentBusAPI {
    emit(event: PropsWithType<XEventsTypes, void>): void;
    emit<Event extends XEvent>(event: Event, payload: XEventPayload<Event>, metadata?: Omit<WireMetadata, 'moduleName'>): void;
    on: XBus['on'];
}

// @public
export function xComponentMixin(module: AnyXModule): ComponentOptions<Vue_2>;

// @internal
export const XComponentModule: unique symbol;

// @public
export function XEmit<Event extends XEvent>(xEvent: Event, { immediate, deep }?: WatchOptions): DecoratorFor<XEventPayload<Event> | undefined>;

// @public
export type XEvent = keyof XEventsTypes;

// @public
export type XEventArrayPayload = PropsWithType<XEventsTypes, any[]>;

// @public
export type XEventPayload<Event extends XEvent> = XEventsTypes[Event] extends void ? undefined : XEventsTypes[Event];

// @public
export type XEventsOf<Type> = PropsWithType<XEventsTypes, Type>;

// Warning: (ae-forgotten-export) The symbol "FacetsXEvents" needs to be exported by the entry point index.d.ts
//
// @public
export interface XEventsTypes extends DeviceXEvents, EmpathizeXEvents, FacetsXEvents, HistoryQueriesXEvents, IdentifierResultsXEvents, NextQueriesXEvents, PopularSearchesXEvents, QuerySuggestionsXEvents, SearchXEvents, SearchBoxXEvents, RecommendationsXEvents, RelatedTagsXEvents, ExtraParamsXEvents {
    AdapterConfigChanged: unknown;
    ColumnsNumberProvided: number;
    SuggestionsDisplayed: Suggestion[];
    TogglePanelStateChanged: boolean;
    UserAcceptedAQuery: string;
    UserAcceptedSpellcheckQuery: string;
    UserAlmostReachedScrollEnd: number;
    UserChangedScrollDirection: ScrollDirection;
    UserClickedAResult: Result;
    UserClickedCloseEventsModal: void;
    UserClickedCloseModal: string;
    UserClickedColumnPicker: number;
    UserClickedOpenEventsModal: void;
    UserClickedOpenModal: string;
    UserClickedOutOfEventsModal: void;
    UserClickedOutOfModal: string;
    UserClickedPanelToggleButton: string;
    UserClickedResultAddToCart: Result;
    UserClickedScrollToTop: string;
    UserOpenXProgrammatically: void;
    UserPressedArrowKey: ArrowKey;
    UserReachedEmpathizeTop: void;
    UserReachedScrollEnd: void;
    UserReachedScrollStart: void;
    UserRightClickedAResult: Result;
    UserScrolled: number;
    UserSelectedASuggestion: Suggestion;
}

// Warning: (ae-forgotten-export) The symbol "AnyInjectKey" needs to be exported by the entry point index.d.ts
//
// @public
export function XInject<Type>(injectKey: AnyInjectKey<Type>, defaultValue?: Type): DecoratorFor<Type>;

// @public
export interface XInjectKey<Type> extends String {
}

// @public
export class XInstaller {
    constructor(options: InstallXOptions);
    // @internal
    protected applyConfigToAdapter(adapterConfig: any): void;
    // @internal
    protected createAPI(): void;
    // @internal
    protected createApp(extraPlugins: VueConstructorPartialArgument, snippetConfig: SnippetConfig): Vue_2 | undefined;
    // @internal
    protected createBus(): XBus;
    // @internal
    protected getAdapterConfig({ instance, env, lang, searchLang, scope, consent, currency, documentDirection, ...extraParams }: SnippetConfig): unknown;
    // @internal
    protected getMountingTarget(elementOrSelector?: string | Element): Element;
    // @internal
    protected getPluginOptions(): XPluginOptions;
    // @internal
    protected getVue(): VueConstructor;
    init(snippetConfig: SnippetConfig): Promise<{
        app: Vue_2 | undefined;
        api: XAPI | undefined;
        bus: XBus;
        plugin: PluginObject<XPluginOptions>;
    }>;
    // @internal
    protected installExtraPlugins(snippet: SnippetConfig, bus: XBus): Promise<VueConstructorPartialArgument>;
    // @internal
    protected installPlugin(pluginOptions: XPluginOptions, bus: XBus): PluginObject<XPluginOptions>;
    // (undocumented)
    protected readonly options: InstallXOptions;
}

// @public
export interface XModule<StoreModule extends AnyXStoreModule> {
    name: XModuleName;
    storeEmitters: StoreEmitters<StoreModule>;
    storeModule: StoreModule;
    wiring: Partial<Wiring>;
}

// @public
export type XModuleName = keyof XModulesTree;

// @public
export interface XModuleOptions<ModuleName extends XModuleName> {
    config?: DeepPartial<ExtractState<ModuleName> extends {
        config: infer Config;
    } ? Config : never>;
    wiring?: Partial<Wiring>;
}

// @public
export type XModulesOptions = {
    [ModuleName in XModuleName]?: XModuleOptions<ModuleName>;
};

// @internal
export type XModuleState = {
    [Key in keyof RootXStoreState['x']]: null;
};

// @public
export interface XModulesTree {
    // (undocumented)
    device: DeviceXModule;
    // (undocumented)
    empathize: EmpathizeXModule;
    // (undocumented)
    extraParams: ExtraParamsXModule;
    // (undocumented)
    facets: FacetsXModule;
    // (undocumented)
    historyQueries: HistoryQueriesXModule;
    // (undocumented)
    identifierResults: IdentifierResultsXModule;
    // (undocumented)
    nextQueries: NextQueriesXModule;
    // (undocumented)
    noSuggestions: NoSuggestionsXModule;
    // (undocumented)
    popularSearches: PopularSearchesXModule;
    // (undocumented)
    querySuggestions: QuerySuggestionsXModule;
    // (undocumented)
    recommendations: RecommendationsXModule;
    // (undocumented)
    relatedTags: RelatedTagsXModule;
    // (undocumented)
    search: SearchXModule;
    // (undocumented)
    searchBox: SearchBoxXModule;
    // (undocumented)
    tagging: TaggingXModule;
    // (undocumented)
    url: UrlXModule;
}

// @public
export function XOn<Event extends XEvent>(xEvent: Event | Event[] | ((component: Vue_2) => Event | Event[]), metadataFilteringOptions?: Partial<WireMetadata>): DecoratorFor<(payload: XEventPayload<Event>, metadata: WireMetadata) => void>;

// @public
export class XPlugin implements PluginObject<XPluginOptions> {
    constructor(bus: XBus);
    // Warning: (ae-forgotten-export) The symbol "SearchAdapter" needs to be exported by the entry point index.d.ts
    static get adapter(): SearchAdapter;
    // @internal
    protected adapter: SearchAdapter;
    // @internal
    protected applyMixins(): void;
    static get bus(): XBus;
    // @internal
    protected bus: XBus;
    // @internal
    protected createAdapterConfigChangedListener(): void;
    // @internal
    protected customizeStoreModule({ state: defaultState, ...actionsGettersMutations }: AnyXStoreModule, { state: xModuleState, ...newActionsGettersMutations }: AnyXStoreModuleOption, configOptions: unknown): AnyXStoreModule;
    // @internal
    protected static getInstance(): XPlugin;
    // @internal
    protected getPrivateXModuleOptions(name: XModuleName): PrivateXModuleOptions<AnyXModule> | undefined;
    // @internal
    protected getXModuleOptions(name: XModuleName): XModuleOptions<any> | undefined;
    // @internal
    install(vue: VueConstructor, options?: XPluginOptions): void;
    // @internal
    protected installedXModules: Set<string>;
    // @internal
    protected static instance?: XPlugin;
    // @internal
    protected isInstalled: boolean;
    // @internal
    protected isSimpleSelector(stateSelector: AnySimpleStateSelector | AnyStateSelector): stateSelector is AnySimpleStateSelector;
    // @internal
    protected static lazyRegisterXModule(xModule: AnyXModule): void;
    // @internal
    protected normalizeStateSelector(stateSelector: AnySimpleStateSelector | AnyStateSelector): Required<AnyStateSelector>;
    // @internal
    protected options: XPluginOptions;
    // @internal
    protected static pendingXModules: Partial<Record<XModuleName, AnyXModule>>;
    // @internal
    protected registerFilters(): void;
    // @internal
    protected registerInitialModules(): void;
    // @internal
    protected registerPendingXModules(): void;
    // @internal
    protected registerStore(): void;
    // @internal
    protected registerStoreEmitters(name: XModuleName, storeModule: AnyXStoreModule, storeEmitters: AnyStoreEmitters): void;
    // @internal
    protected registerStoreModule(name: XModuleName, storeModule: AnyXStoreModule): void;
    // @internal
    protected registerWiring(name: XModuleName, wiring: Partial<Wiring>): void;
    static registerXModule(xModule: AnyXModule): void;
    // @internal
    protected registerXModule({ name, wiring, storeModule, storeEmitters }: AnyXModule): void;
    // @internal
    static resetInstance(): void;
    static get store(): Store<RootXStoreState>;
    // @internal
    protected store: Store<any>;
    // @internal
    protected vue: VueConstructor;
}

// @public
export const xPlugin: XPlugin;

// @public
export interface XPluginOptions {
    __PRIVATE__xModules?: PrivateXModulesOptions;
    adapter: SearchAdapter;
    initialXModules?: AnyXModule[];
    store?: Store<any>;
    xModules?: XModulesOptions;
}

// @public
export function XProvide<Type>(provideKey: AnyInjectKey<Type>): DecoratorFor<Type>;

// @public
export interface XStoreModule<State extends Record<keyof State, any>, Getters extends Record<keyof Getters, any>, Mutations extends MutationsDictionary<Mutations>, Actions extends ActionsDictionary<Actions>> {
    // (undocumented)
    actions: ActionsTree<State, Getters, Mutations, Actions>;
    // (undocumented)
    getters: GettersTree<State, Getters>;
    // (undocumented)
    mutations: MutationsTree<State, Mutations>;
    // (undocumented)
    state: () => State;
}

// @public
export type XStoreModuleOptions<StoreModule extends AnyXStoreModule> = StoreModule extends XStoreModule<infer State, infer Getters, infer Mutations, infer Actions> ? {
    state?: DeepPartial<State>;
    actions?: DeepPartial<ActionsTree<State, Getters, Mutations, Actions>>;
    getters?: DeepPartial<GettersTree<State, Getters>>;
    mutations?: DeepPartial<MutationsTree<State, Mutations>>;
} : never;

// Warnings were encountered during analysis:
//
// dist/types/components/filters/labels/base-price-filter-label.vue.d.ts:12:9 - (ae-forgotten-export) The symbol "RangeValue" needs to be exported by the entry point index.d.ts
// src/x-modules/facets/store/emitters.ts:18:1 - (ae-forgotten-export) The symbol "isNewQuery" needs to be exported by the entry point index.d.ts
// src/x-modules/identifier-results/store/emitters.ts:9:39 - (ae-forgotten-export) The symbol "SearchByIdRequest" needs to be exported by the entry point index.d.ts
// src/x-modules/next-queries/store/emitters.ts:10:33 - (ae-forgotten-export) The symbol "NextQueriesRequest" needs to be exported by the entry point index.d.ts
// src/x-modules/popular-searches/store/emitters.ts:11:1 - (ae-forgotten-export) The symbol "SuggestionsRequest" needs to be exported by the entry point index.d.ts
// src/x-modules/recommendations/store/emitters.ts:10:1 - (ae-forgotten-export) The symbol "TopRecommendationsRequest" needs to be exported by the entry point index.d.ts
// src/x-modules/related-tags/store/emitters.ts:9:33 - (ae-forgotten-export) The symbol "RelatedTagsRequest" needs to be exported by the entry point index.d.ts
// src/x-modules/search/store/emitters.ts:9:28 - (ae-forgotten-export) The symbol "SearchRequest" needs to be exported by the entry point index.d.ts

```
