<script lang="ts">
  import Vue, { CreateElement, VNode } from 'vue';
  import { Component, Prop } from 'vue-property-decorator';
  import { noOp } from '../utils';

  /* eslint-disable @typescript-eslint/unbound-method */
  /**
   * A replacement component for Vue's transition-group, that also adds the option to stagger
   * the animations.
   *
   * @public
   */
  @Component
  export default class StaggeringTransitionGroup extends Vue {
    /**
     * The name of the transition. Used to generate the CSS classes.
     *
     * @internal
     */
    @Prop({ default: 'v' })
    public name!: string;

    /** The CSS move class name.
     *
     * @internal
     */
    @Prop()
    public moveClass!: string;

    /**
     * The tag of the node to render to the DOM.
     *
     * @internal
     */
    @Prop({ default: 'div' })
    public tag!: string;

    /**
     * The time in ms to stagger each item.
     *
     * @internal
     */
    @Prop({ default: 25 })
    public staggering!: number;

    /**
     * The CSS class for the moving transitions.
     *
     * @returns The move transition name.
     * @internal
     */
    protected get moveClassName(): string {
      return this.moveClass ?? `${this.name}-move`;
    }

    /**
     * The transition data contains the needed events and props to perform a transition using Vue
     * virtual node's API.
     *
     * The `beforeLeave` hook is extended to also restore the previous position of the element using
     * the position absolute.
     * The `afterEnter` and `afterLeave` hooks are extended to also clean the transition delay
     * applied by the stagger.
     *
     * @returns The transition data for Vue virtual nodes.
     * @internal
     */
    protected get transitionData(): TransitionData {
      const transitionData: TransitionData = { ...this.$props, ...this.$attrs, ...this.$listeners };

      transitionData.beforeLeave = this.addRestorePositionHook(transitionData.beforeLeave);
      transitionData.afterEnter = this.addClearStaggeringCall(transitionData.afterEnter);
      transitionData.afterLeave = this.addClearStaggeringCall(transitionData.afterLeave);

      return transitionData;
    }

    /** The list of old virtual nodes, generated by the previous called render method.
     *
     * @internal */
    protected oldChildren!: TransitionVNode[];
    /** The list of new virtual nodes, generated by the last called render method.
     *
     * @internal */
    protected newChildren!: TransitionVNode[];
    /** A map containing the previous positions for each DOM element rendered by this component.
     * This is used together with the `newPositions` to calculate the move transition.
     *
     * @internal */
    protected oldPositions!: WeakMap<Element, DOMRect>;
    /** A map containing the last positions for each DOM element rendered by this component.
     * This is used together with the `oldPositions` to calculate the move transition.
     *
     * @internal */
    protected newPositions!: WeakMap<Element, DOMRect>;
    /** A map containing the move cleanup functions pending to have been called. When invoked
     * this functions remove all the styles and classes associated to the move transition.
     *
     * @internal */
    protected pendingCleanupMoveCallbacks!: WeakMap<Element, () => void>;
    /** The counter for the stagger, used to calculate the delay for the transition of each child
     * element. It is reset every time the render method is triggered.
     *
     * @internal */
    protected staggerCounter!: number;
    /** The bounds of the container rendered using the `tag` prop. This is used to calculate the
     * relative positions of each leaving child, which are then applied with the position absolute.
     *
     * @internal */
    protected wrapperBounds!: DOMRect;

    beforeCreate(): void {
      /* Initialize properties here to avoid making them reactive,
      which would cause infinite loops */
      this.oldChildren = [];
      this.newChildren = [];
      this.oldPositions = new WeakMap();
      this.newPositions = new WeakMap();
      this.pendingCleanupMoveCallbacks = new WeakMap<Element, () => void>();
      this.staggerCounter = 0;
    }

    render(createElement: CreateElement): VNode {
      this.staggerCounter = 0;
      // New children are now the old ones
      this.oldChildren = this.newChildren;
      // Only vnodes with a tag (i.e. no HTML comments) and with a `key` property are valid.
      this.newChildren = (this.$slots.default ?? []).filter(this.isTransitionValidVNode);

      // Apply transition data to both new and old nodes & store the position of the old nodes.
      this.newChildren.forEach(this.addTransitionData);
      this.oldChildren.forEach(this.syncOldNodes);

      return createElement(
        this.tag,
        { staticClass: 'x-staggering-transition-group' },
        this.newChildren
      );
    }

    mounted(): void {
      this.newChildren.forEach(this.applyStagger);
    }

    beforeUpdate(): void {
      this.wrapperBounds = this.$el.getBoundingClientRect();
    }

    updated(): void {
      this.newChildren.forEach(this.recordNewPosition);
      const { leavingNodes, stayingNodes, enteringNodes } = this.getNodesByTransitionType();

      leavingNodes.forEach(this.applyStagger);
      const movedChildren = stayingNodes.filter(this.applyTranslation);
      const movedStagger = movedChildren.map(this.getNextTransitionDelay);
      enteringNodes.forEach(this.applyStagger);

      // force reflow to put everything in position
      document.body.getBoundingClientRect();

      movedChildren.forEach(this.startMoveAnimation(movedStagger));
    }

    /**
     * Extends the provided leave transition hook restoring the position of the element with an
     * absolute position.
     * Additionally, it removes the element position from the maps of positions.
     *
     * @param transitionHook - The leave transition hook to extend.
     * @returns The new leave transition hook extended.
     * @internal
     */
    protected addRestorePositionHook(transitionHook: TransitionHook = noOp): TransitionHook {
      return element => {
        const position = this.oldPositions.get(element)!;
        const elementComputedStyle = window.getComputedStyle(element);
        const marginTopComputedStyle = parseFloat(elementComputedStyle.marginTop);
        const marginLeftComputedStyle = parseFloat(elementComputedStyle.marginLeft);
        const style = element.style;
        style.position = 'absolute';
        style.top = `${position.top - this.wrapperBounds.top - marginTopComputedStyle}px`;
        style.left = `${position.left - this.wrapperBounds.left - marginLeftComputedStyle}px`;
        this.newPositions.delete(element);
        this.oldPositions.delete(element);
        const pendingCallback = this.pendingCleanupMoveCallbacks.get(element);
        pendingCallback?.();
        transitionHook(element);
      };
    }

    /**
     * Extends the provided transition hook clearing the transition delay.
     *
     * @param transitionHook - The transition hook to extend.
     * @returns The new transition hook, that also clears the transitionDelay from the element.
     * @internal
     */
    protected addClearStaggeringCall(transitionHook: TransitionHook = noOp): TransitionHook {
      return element => {
        element.style.transitionDelay = '';
        transitionHook(element);
      };
    }

    /**
     * Returns if the vNode contains a non empty key, and a non empty tag.
     *
     * @param vNode - The VNode to check if it is a valid transition node, containing a `tag` and a
     * `key` property.
     * @returns True when the vNode contains a non empty key and a non empty tag. False otherwise.
     * @internal
     */
    protected isTransitionValidVNode(vNode: VNode): vNode is TransitionVNode {
      // TODO Add warning with logger: <staggering-transition-group> children must be keyed.
      return !!vNode.key && !!vNode.tag;
    }

    /**
     * Adds the generated transition data to the vNode, creating the `data` property if necessary.
     *
     * @param vNode - The VNode to add the transition data to.
     * @internal
     */
    protected addTransitionData(vNode: TransitionVNode): void {
      if (!vNode.data) {
        vNode.data = {};
      }
      vNode.data.transition = this.transitionData;
    }

    /**
     * Re-applies the transition data to an old node, just in case it changed from the previous
     * render call. It also records the position of the node, to then calculate the move
     * transitions.
     *
     * @param vNode - The vNode to add the transition data to, and record his current position as
     * old.
     * @internal
     */
    protected syncOldNodes(vNode: TransitionVNode): void {
      // Synchronize transition data, in case it changed in the last frame.
      // We can trust data to be defined because each new node has the transition applied
      vNode.data!.transition = this.transitionData;
      this.recordOldPosition(vNode);
    }

    /**
     * Saves the position of the vNode in the map of old positions.
     *
     * @param vNode - The node to store its position.
     * @internal
     */
    protected recordOldPosition(vNode: TransitionVNode): void {
      const element = vNode.elm;
      this.oldPositions.set(element, element.getBoundingClientRect());
    }

    /**
     * Saves the position of the vNode in the map of new positions.
     *
     * @param vNode - The node to store its position.
     * @internal
     */
    protected recordNewPosition(vNode: TransitionVNode): void {
      const element = vNode.elm;
      this.newPositions.set(element, element.getBoundingClientRect());
    }

    /**
     * Splits the children of the component into three groups:
     * - Nodes that are leaving.
     * - Nodes that are entering.
     * - Nodes that stay.
     *
     * This is then used to apply the stagger in the correct order: leave -\> move -\> enter.
     *
     * @returns The children nodes, divided in different groups depending on if they are leaving,
     * staying or entering.
     * @internal
     */
    protected getNodesByTransitionType(): TransitionTypeNodes {
      const leave = this.oldChildren.filter(child => !this.newPositions.has(child.elm));
      const enter = this.newChildren.filter(child => !this.oldPositions.has(child.elm));
      const stay = this.oldChildren.filter(child => this.newPositions.has(child.elm));
      return {
        leavingNodes: leave,
        enteringNodes: enter,
        stayingNodes: stay
      };
    }

    /**
     * Applies an incremental delay to the virtual node element.
     *
     * @param vNode - The virtual node to apply the stagger to.
     * @internal
     */
    protected applyStagger(vNode: TransitionVNode): void {
      vNode.elm.style.transitionDelay = this.getNextTransitionDelay();
    }

    /**
     * Calculates the next transition delay property, incrementing the `staggerCounter` property
     * each time it is called.
     *
     * @returns The value for the next element `style.transitionDelay` property.
     * @internal
     */
    protected getNextTransitionDelay(): string {
      return `${this.staggerCounter++ * this.staggering}ms`;
    }

    /**
     * Calculates if the virtual node should have a move transition. If its has it, then it
     * applies it immediately using the `style.transform`.
     *
     * @param vNode - The virtual node to calculate if it should have a move transition.
     * @returns True when a move transition was applied to the virtual node.
     * @internal
     */
    protected applyTranslation(vNode: TransitionVNode): boolean {
      const oldPosition = this.oldPositions.get(vNode.elm as Element)!;
      const newPosition = this.newPositions.get(vNode.elm as Element)!;
      const dx = oldPosition.left - newPosition.left;
      const dy = oldPosition.top - newPosition.top;
      if (dx !== 0 || dy !== 0) {
        const style = vNode.elm.style;
        style.transform = `translate3d(${dx}px,${dy}px,0)`;
        style.transitionDuration = '0s';
        return true;
      }
      return false;
    }

    /**
     * Generates a function to start the moving animations to each node that it needs them with the
     * provided stagger.
     *
     * @param moveStagger - A list containing the delay to add to each node.
     * @returns A function that starts the moving animation with the provided stagger to a single
     * virtual node.
     * @internal
     */
    protected startMoveAnimation(
      moveStagger: string[]
    ): (vNode: TransitionVNode, index: number) => void {
      return (vNode, index) => {
        const element = vNode.elm;
        const style = element.style;
        element.classList.add(this.moveClassName);
        style.transform = style.transitionDuration = '';
        style.transitionDelay = moveStagger[index];
        const cleanMoveTransition = (event?: TransitionEvent): void => {
          if (!event || (event.target === element && /transform$/.test(event.propertyName))) {
            element.removeEventListener('transitionend', cleanMoveTransition);
            element.style.transitionDelay = '';
            element.classList.remove(this.moveClassName);
            this.pendingCleanupMoveCallbacks.delete(element);
          }
        };
        this.pendingCleanupMoveCallbacks.set(element, cleanMoveTransition);
        element.addEventListener('transitionend', cleanMoveTransition);
      };
    }
  }

  /**
   * Contains arrays of nodes, splitted by the action they should have.
   */
  interface TransitionTypeNodes {
    leavingNodes: TransitionVNode[];
    stayingNodes: TransitionVNode[];
    enteringNodes: TransitionVNode[];
  }

  /**
   * Safe transition version of the VNode type, with the required non optional properties.
   */
  interface TransitionVNode extends VNode {
    elm: HTMLElement;
    tag: string;
    key: string;
  }

  /**
   * Vue's VNode {@link https://vuejs.org/v2/api/#transition | transition} data props and events.
   */
  interface TransitionData {
    name?: string;
    appear?: boolean;
    css?: boolean;
    type?: 'transition' | 'animation'; // Unused
    mode?: 'out-in' | 'in-out'; // Unused
    duration?: number;
    enterClass?: string;
    leaveClass?: string;
    appearClass?: string;
    enterToClass?: string;
    leaveToClass?: string;
    appearToClass?: string;
    enterActiveClass?: string;
    leaveActiveClass?: string;
    appearActiveClass?: string;
    beforeEnter?: TransitionHook;
    enter?: TransitionHook;
    afterEnter?: TransitionHook;
    beforeLeave?: TransitionHook;
    leave?: TransitionHook;
    afterLeave?: TransitionHook;
  }

  /**
   * A function that receives an HTMLElement. Used to perform actions when the different phases
   * of Vue transitions happens.
   */
  type TransitionHook = (element: HTMLElement) => void;
</script>

<style lang="scss" scoped>
  .x-staggering-transition-group {
    position: relative;
  }
</style>

<docs>
#Examples

## Basic example

Apart from all the props and events that the classic transition group has, the staggering
transition group also exposes a new `stagger` property, which allows to configure the delay for
each one of the nodes when animating.

```vue
<staggering-transition-group
  appear
  :stagger="50"
  name="staggered-fade-slide-"
>
  <!-- @slot (Required) Transition-group content -->
  <slot />
</staggering-transition-group>
```

</docs>
