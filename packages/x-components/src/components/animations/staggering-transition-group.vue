<script lang="ts">
  import {
    computed,
    defineComponent,
    h,
    onBeforeUpdate,
    onMounted,
    onUpdated,
    ref,
    VNode
  } from 'vue';
  import { noOp } from '../../utils/function';

  /* eslint-disable @typescript-eslint/unbound-method */
  /**
   * A replacement component for Vue's transition-group, that also adds the option to stagger
   * the animations.
   *
   * @public
   */
  export default defineComponent({
    name: 'StaggeringTransitionGroup',
    props: {
      /**
       * The name of the transition. Used to generate the CSS classes.
       */
      name: {
        type: String,
        default: 'v'
      },
      /**
       * The CSS move class name.
       */
      moveClass: String,
      /**
       * The tag of the node to render to the DOM.
       */
      tag: {
        type: String,
        default: 'div'
      },
      /**
       * The time in ms to stagger each item.
       */
      staggering: {
        type: Number,
        default: 25
      }
    },
    setup(props, { attrs, listeners, slots }) {
      const el = ref<HTMLElement>();

      /**
       * The CSS class for the moving transitions.
       *
       * @returns The move transition name.
       */
      const moveClassName = computed<string>(() => {
        return props.moveClass ?? `${props.name}-move`;
      });

      /**
       * The transition data contains the needed events and props to perform a transition using Vue
       * virtual node's API.
       *
       * The `beforeLeave` hook is extended to also restore the previous position of the element using
       * the position absolute.
       * The `afterEnter` and `afterLeave` hooks are extended to also clean the transition delay
       * applied by the stagger.
       *
       * @returns The transition data for Vue virtual nodes.
       */
      const transitionData = computed<TransitionData>(() => {
        const transitionData: TransitionData = { ...props, ...attrs, ...listeners };

        transitionData.beforeLeave = addRestorePositionHook(transitionData.beforeLeave);
        transitionData.afterEnter = addClearStaggeringCall(transitionData.afterEnter);
        transitionData.afterLeave = addClearStaggeringCall(transitionData.afterLeave);

        return transitionData;
      });

      // Initialize properties here to avoid making them reactive, which would cause infinite loops.
      /**
       * The list of old virtual nodes, generated by the previous called render method.
       */
      let oldChildren: TransitionVNode[] = [];
      /**
       * The list of new virtual nodes, generated by the last called render method.
       */
      let newChildren: TransitionVNode[] = [];
      /**
       * A map containing the previous positions relative to the container, for each item
       * rendered inside the slot of this component.
       * This is used together with the `newPositions` to calculate the move transition.
       */
      const oldPositions: WeakMap<Element, Bounds> = new WeakMap();
      /**
       * A map containing the new positions relative to the container, for each item
       * rendered inside the slot of this component.
       * This is used together with the `newPositions` to calculate the move transition.
       */
      const newPositions: WeakMap<Element, Bounds> = new WeakMap();
      /**
       * A map containing the move cleanup functions pending to have been called. When invoked
       * this functions remove all the styles and classes associated to the move transition.
       */
      const pendingCleanupMoveCallbacks: WeakMap<Element, () => void> = new WeakMap<
        Element,
        () => void
      >();
      /**
       * The counter for the stagger, used to calculate the delay for the transition of each child
       * element. It is reset every time the render method is triggered.
       */
      let staggerCounter = 0;
      /**
       * The bounds of the container rendered using the `tag` prop. This is used to calculate the
       * relative positions of each leaving child, which are then applied with the position absolute.
       */
      let wrapperBounds: DOMRect;

      onMounted(() => {
        newChildren.forEach(applyStagger);
      });

      onBeforeUpdate(() => {
        wrapperBounds = el.value!.getBoundingClientRect();
      });

      onUpdated(() => {
        wrapperBounds = el.value!.getBoundingClientRect();
        newChildren.forEach(recordNewPosition);
        const { leavingNodes, stayingNodes, enteringNodes } = getNodesByTransitionType();

        leavingNodes.forEach(vNode => {
          applyStagger(vNode);
          disableClickingEvents(vNode);
        });
        const movedChildren = stayingNodes.filter(applyTranslation);
        const movedStagger = movedChildren.map(getNextTransitionDelay);
        enteringNodes.forEach(applyStagger);

        // force reflow to put everything in position
        document.body.getBoundingClientRect();

        movedChildren.forEach(startMoveAnimation(movedStagger));
      });

      /**
       * Extends the provided leave transition hook restoring the position of the element with an
       * absolute position.
       * Additionally, it removes the element position from the maps of positions.
       *
       * @param transitionHook - The leave transition hook to extend.
       * @returns The new leave transition hook extended.
       */
      function addRestorePositionHook(transitionHook: TransitionHook = noOp): TransitionHook {
        return element => {
          const { top, left, width, height } = oldPositions.get(element)!;
          const { marginTop, marginLeft } = window.getComputedStyle(element);
          const style = element.style;
          style.position = 'absolute';
          style.top = `${top - parseFloat(marginTop)}px`;
          style.left = `${left - parseFloat(marginLeft)}px`;
          style.width = `${width}px`;
          style.height = `${height}px`;
          newPositions.delete(element);
          oldPositions.delete(element);
          const pendingCallback = pendingCleanupMoveCallbacks.get(element);
          pendingCallback?.();
          transitionHook(element);
        };
      }

      /**
       * Extends the provided transition hook clearing the transition delay.
       *
       * @param transitionHook - The transition hook to extend.
       * @returns The new transition hook, that also clears the transitionDelay from the element.
       */
      function addClearStaggeringCall(transitionHook: TransitionHook = noOp): TransitionHook {
        return element => {
          element.style.transitionDelay = '';
          transitionHook(element);
        };
      }

      /**
       * Returns if the vNode contains a non empty key, and a non empty tag.
       *
       * @param vNode - The VNode to check if it is a valid transition node, containing a `tag` and a
       * `key` property.
       * @returns True when the vNode contains a non empty key and a non empty tag. False otherwise.
       */
      function isTransitionValidVNode(vNode: VNode): vNode is TransitionVNode {
        // TODO Add warning with logger: <staggering-transition-group> children must be keyed.
        return !!vNode.key && !!vNode.tag;
      }

      /**
       * Adds the generated transition data to the vNode, creating the `data` property if necessary.
       *
       * @param vNode - The VNode to add the transition data to.
       */
      function addTransitionData(vNode: TransitionVNode): void {
        if (!vNode.data) {
          vNode.data = {};
        }
        vNode.data.transition = transitionData.value;
      }

      /**
       * Re-applies the transition data to an old node, just in case it changed from the previous
       * render call. It also records the position of the node, to then calculate the move
       * transitions.
       *
       * @param vNode - The vNode to add the transition data to, and record his current position as
       * old.
       */
      function syncOldNodes(vNode: TransitionVNode): void {
        // Synchronize transition data, in case it changed in the last frame.
        // We can trust data to be defined because each new node has the transition applied
        vNode.data!.transition = transitionData.value;
        recordOldPosition(vNode);
      }

      /**
       * Saves the position of the vNode in the map of old positions.
       *
       * @param vNode - The node to store its position.
       */
      function recordOldPosition(vNode: TransitionVNode): void {
        oldPositions.set(vNode.elm, createRelativeBounds(vNode));
      }

      /**
       * Saves the position of the vNode in the map of new positions.
       *
       * @param vNode - The node to store its position.
       */
      function recordNewPosition(vNode: TransitionVNode): void {
        newPositions.set(vNode.elm, createRelativeBounds(vNode));
      }

      /**
       * Creates an object containing the position of the vNode relative to its container.
       *
       * @param vNode - The virtual node to store its relative position.
       * @returns The relative bounds of the provided virtual node.
       */
      function createRelativeBounds(vNode: TransitionVNode): Bounds {
        const { left, top, width, height } = vNode.elm.getBoundingClientRect();
        const { left: wrapperLeft, top: wrapperTop } = wrapperBounds;
        return {
          left: left - wrapperLeft,
          top: top - wrapperTop,
          width,
          height
        };
      }

      /**
       * Splits the children of the component into three groups:
       * - Nodes that are leaving.
       * - Nodes that are entering.
       * - Nodes that stay.
       *
       * This is then used to apply the stagger in the correct order: leave -\> move -\> enter.
       *
       * @returns The children nodes, divided in different groups depending on if they are leaving,
       * staying or entering.
       */
      function getNodesByTransitionType(): TransitionTypeNodes {
        const leave = oldChildren.filter(child => !newPositions.has(child.elm));
        const enter = newChildren.filter(child => !oldPositions.has(child.elm));
        const stay = oldChildren.filter(child => newPositions.has(child.elm));
        return {
          leavingNodes: leave,
          enteringNodes: enter,
          stayingNodes: stay
        };
      }

      /**
       * Applies an incremental delay to the virtual node element.
       *
       * @param vNode - The virtual node to apply the stagger to.
       */
      function applyStagger(vNode: TransitionVNode): void {
        vNode.elm.style.transitionDelay = getNextTransitionDelay();
      }

      /**
       * Disables listening to click events in a virtual node element.
       *
       * @remarks This is done to avoid letting the user click elements that are performing the moving
       * animation to leave the DOM but are still rendered.
       *
       * @param vNode - The virtual node to disable listening to click events.
       */
      function disableClickingEvents(vNode: TransitionVNode): void {
        vNode.elm.style.pointerEvents = 'none';
      }

      /**
       * Calculates the next transition delay property, incrementing the `staggerCounter` property
       * each time it is called.
       *
       * @returns The value for the next element `style.transitionDelay` property.
       */
      function getNextTransitionDelay(): string {
        return `${staggerCounter++ * props.staggering}ms`;
      }

      /**
       * Calculates if the virtual node should have a move transition. If its has it, then it
       * applies it immediately using the `style.transform`.
       *
       * @param vNode - The virtual node to calculate if it should have a move transition.
       * @returns True when a move transition was applied to the virtual node.
       */
      function applyTranslation(vNode: TransitionVNode): boolean {
        const oldPosition = oldPositions.get(vNode.elm as Element)!;
        const newPosition = newPositions.get(vNode.elm as Element)!;
        const dx = oldPosition.left - newPosition.left;
        const dy = oldPosition.top - newPosition.top;
        if (dx !== 0 || dy !== 0) {
          const style = vNode.elm.style;
          style.transform = `translate3d(${dx}px,${dy}px,0)`;
          style.transitionDuration = '0s';
          return true;
        }
        return false;
      }

      /**
       * Generates a function to start the moving animations to each node that it needs them with the
       * provided stagger.
       *
       * @param moveStagger - A list containing the delay to add to each node.
       * @returns A function that starts the moving animation with the provided stagger to a single
       * virtual node.
       */
      function startMoveAnimation(
        moveStagger: string[]
      ): (vNode: TransitionVNode, index: number) => void {
        return (vNode, index) => {
          const element = vNode.elm;
          const style = element.style;
          element.classList.add(moveClassName.value);
          style.transform = style.transitionDuration = '';
          style.transitionDelay = moveStagger[index];
          const cleanMoveTransition = (event?: TransitionEvent): void => {
            if (!event || (event.target === element && /transform$/.test(event.propertyName))) {
              element.removeEventListener('transitionend', cleanMoveTransition);
              element.style.transitionDelay = '';
              element.classList.remove(moveClassName.value);
              pendingCleanupMoveCallbacks.delete(element);
            }
          };
          pendingCleanupMoveCallbacks.set(element, cleanMoveTransition);
          element.addEventListener('transitionend', cleanMoveTransition);
        };
      }

      return () => {
        staggerCounter = 0;
        // New children are now the old ones
        oldChildren = newChildren;
        // Only vnodes with a tag (i.e. no HTML comments) and with a `key` property are valid.
        newChildren = (
          (typeof slots.default === 'function' ? slots.default() : slots.default) ?? []
        ).filter(isTransitionValidVNode);

        // Apply transition data to both new and old nodes & store the position of the old nodes.
        newChildren.forEach(addTransitionData);
        oldChildren.forEach(syncOldNodes);

        return h(props.tag, { ref: el, class: 'x-staggering-transition-group' }, newChildren);
      };
    }
  });

  /**
   * Contains arrays of nodes, splitted by the action they should have.
   */
  interface TransitionTypeNodes {
    leavingNodes: TransitionVNode[];
    stayingNodes: TransitionVNode[];
    enteringNodes: TransitionVNode[];
  }

  /**
   * Safe transition version of the VNode type, with the required non optional properties.
   */
  interface TransitionVNode extends VNode {
    elm: HTMLElement;
    tag: string;
    key: string;
  }

  /**
   * Vue's VNode {@link https://vuejs.org/v2/api/#transition} data props and events.
   */
  interface TransitionData {
    name?: string;
    appear?: boolean;
    css?: boolean;
    type?: 'transition' | 'animation'; // Unused
    mode?: 'out-in' | 'in-out'; // Unused
    duration?: number;
    enterClass?: string;
    leaveClass?: string;
    appearClass?: string;
    enterToClass?: string;
    leaveToClass?: string;
    appearToClass?: string;
    enterActiveClass?: string;
    leaveActiveClass?: string;
    appearActiveClass?: string;
    beforeEnter?: TransitionHook;
    enter?: TransitionHook;
    afterEnter?: TransitionHook;
    beforeLeave?: TransitionHook;
    leave?: TransitionHook;
    afterLeave?: TransitionHook;
  }

  /**
   * A function that receives an HTMLElement. Used to perform actions when the different phases
   * of Vue transitions happens.
   */
  type TransitionHook = (element: HTMLElement) => void;

  /**
   * Represents the dimensions and positions of an element.
   */
  interface Bounds {
    top: number;
    left: number;
    width: number;
    height: number;
  }
</script>

<style lang="scss" scoped>
  .x-staggering-transition-group {
    position: relative;
  }
</style>

<docs lang="mdx">
## Examples

### Basic example

Apart from all the props and events that the classic transition group has, the staggering transition
group also exposes a new `staggering` property, which allows to configure the delay for each one of
the nodes when animating.

```vue
<staggering-transition-group appear :staggering="50" name="staggered-fade-slide-">
  <!-- @slot (Required) Transition-group content -->
  <slot />
</staggering-transition-group>
```
</docs>
