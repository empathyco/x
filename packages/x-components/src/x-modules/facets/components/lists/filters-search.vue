<template>
  <div class="x-filters-search" :class="cssClasses" data-test="filters-search">
    <!--
      @slot Search content. It is the content which triggers the filters sifting.
        @binding {string} query - The query to search in filters.
        @binding {Function} setQuery - The function to set the query. The query is passed as
        parameter.
        @binding {Function} clearQuery - The function to clear the query.
    -->
    <slot name="search" v-bind="{ query, setQuery, clearQuery }">
      <input
        @input="setQuery($event.target.value)"
        :value="query"
        type="search"
        class="x-filters-search__input x-input"
        data-test="filters-search-input"
        :aria-label="'search into the filter values'"
      />
    </slot>
    <!--
      @slot (Required) Sifted filters content.
        @binding {Filter[]} siftedFilters - Sifted filters data.
    -->
    <slot :siftedFilters="siftedFilters"></slot>
  </div>
</template>

<script lang="ts">
  import { Filter, isBooleanFilter } from '@empathyco/x-types';
  import { computed, defineComponent, PropType, provide, ref, watch } from 'vue';
  import { debounce } from '../../../../utils/debounce';
  import { normalizeString } from '../../../../utils/normalize';
  import { DebouncedFunction, VueCSSClasses } from '../../../../utils/types';
  import { facetsXModule } from '../../x-module';
  import { useRegisterXModule } from '../../../../composables/use-register-x-module';
  import { useFiltersInjection } from '../../composables/use-filters-injection';

  /**
   * Renders the filters sifted with the input query.
   *
   * @public
   */
  export default defineComponent({
    name: 'FiltersSearch',
    xModule: facetsXModule.name,
    props: {
      /**
       * The list of filters to be rendered as slots.
       *
       * @public
       */
      filters: Array as PropType<Filter[]>,

      /**
       * This prop is used in the `HierarchicalFilter` component and only in that case. It is necessary
       * to make the `renderedFilters` to return only the filters of each level of the hierarchy.
       *
       * @public
       */
      parentId: {
        type: String as PropType<Filter['id']>,
        required: false
      },

      /** The debounce time for applying the filter sifting. */
      debounceInMs: {
        type: Number,
        default: 200
      }
    },
    setup(props) {
      useRegisterXModule(facetsXModule);
      const renderedFilters = useFiltersInjection(props);

      let query = ref('');
      let setQueryDebounced: DebouncedFunction<[string]>;

      const debounceInMs = computed(() => props.debounceInMs);

      /**
       * Set the debounce function for setting the query debounced.
       *
       * @internal
       */
      const updateSetQueryDebounced = () => {
        setQueryDebounced = debounce(queryDebounced => {
          query.value = queryDebounced;
        }, props.debounceInMs);
      };
      watch(debounceInMs, updateSetQueryDebounced, { immediate: true });

      /**
       * Sift the array of filters which matches with the query.
       *
       * @returns Array of sifted filters.
       * @internal
       */
      const siftedFilters = computed((): Filter[] => {
        const normalizedQuery = normalizeString(query.value);
        return renderedFilters.value.filter(
          filter =>
            isBooleanFilter(filter) && normalizeString(filter.label).includes(normalizedQuery)
        );
      });
      provide('filters', siftedFilters);

      /**
       * Adds the dynamic css classes to the component.
       *
       * @returns The class to be added to the component.
       * @internal
       */
      const cssClasses = computed((): VueCSSClasses => {
        return { 'x-filters-search--is-sifted': !!query.value };
      });

      /**
       * Set the query through the debounced function.
       *
       * @param query - The query to sift filters.
       * @internal
       */
      const setQuery = (query: string): void => {
        setQueryDebounced(query);
      };

      /**
       * Clear the query.
       *
       * @internal
       */
      const clearQuery = (): void => {
        query.value = '';
      };

      return {
        clearQuery,
        setQuery,
        cssClasses,
        siftedFilters,
        query
      };
    }
  });
</script>

<style lang="scss" scoped>
  .x-filters-search {
    display: flex;
    flex-flow: column nowrap;

    &__input {
      &::-ms-clear {
        display: none;
        width: 0;
        height: 0;
      }

      &::-ms-reveal {
        display: none;
        width: 0;
        height: 0;
      }

      &::-webkit-search-decoration,
      &::-webkit-search-cancel-button,
      &::-webkit-search-results-button,
      &::-webkit-search-results-decoration {
        display: none;
      }
    }
  }
</style>

<docs lang="mdx">
## Examples

It renders an input and a list of filters passed as prop or being injected. The list of filters can
be sifted with the query typed in the input. This component has also a debounce prop to set the time
in milliseconds to apply the filters search. Moreover, it has two scoped slots. The first one for
customize the search triggering with three slot props; the query, a function to set the query by
sifting and a third one for cleaning the query. The second scoped slot is required and it is for
displaying the list of filters sifted. It has a slot prop with these filters sifted.

### Important

The component has two ways of receive the filters list, it can be injected by another component or
be send it as a prop. If the component doesnt have a parent component that receive and exposed a
filters list to their children, it is mandatory to send it as prop.

### Basic usage

Using default and required slot:

```vue
<FiltersSearch :filters="filters" v-slot="{ siftedFilters }">
  <ul v-for="filter in siftedFilters">
    <li :key="filter.id">{{ filter.label }}</li>
  </ul>
</FiltersSearch>
```

Setting debounce time:

```vue
<FiltersSearch :filters="filters" :debounceInMs="500" v-slot="{ siftedFilters }">
  <ul v-for="filter in siftedFilters">
    <li :key="filter.id">{{ filter.label }}</li>
  </ul>
</FiltersSearch>
```

Replacing search triggering:

```vue
<FiltersSearch :filters="filters">
  <template #search="{ query, setQuery, clearQuery }">
    <input
      @input="setQuery($event.target.value)"
      :value="query"
      class="x-input x-filters-search__input"
      :aria-label="filtersSearchInputMessage"/>
    <button @click="clearQuery">X</button>
  </template>
  <template #default="{ siftedFilters }">
    <ul v-for="filter in siftedFilters">
      <li :key="filter.id">{{ filter.label }}</li>
    </ul>
  </template>
</FiltersSearch>
```

> **Using injection**: It can receive the filters list by injection. It only works if it has a
> parent component that receives and exposes the filters list. Using the injection, It is not
> necessary to send the prop to the child components, it has to be send it in the parent component,
> the rest of components will inject this list.

```vue
<Facets v-slot="{ facet }">
  <SlicedFilters :filters="facet.filters" :max="8">
    <FiltersSearch >
        <Filters v-slot="{ filter }">
          <SimpleFilter :filter="filter" data-test="brand-filter" />
        </Filters>
    </FiltersSearch>
  </SlicedFilters>
</Facets>
```
</docs>
